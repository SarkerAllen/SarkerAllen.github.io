{"meta":{"title":"Kevin's Blog","subtitle":"Kevin的技术分享","description":"小白的学习之路","author":"Kevin","url":"https://SarkerAllen.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-07-16T08:20:16.819Z","updated":"2018-07-24T01:49:56.000Z","comments":false,"path":"/404.html","permalink":"https://SarkerAllen.github.io//404.html","excerpt":"","text":".article-title { font-size: 2.1em; } strong a { color: #747474; } .share { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .search2 { height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; } .search2:hover { opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) }; .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } 很抱歉，您所访问的地址并不存在: 回主页 · 所有文章 · 留言板 可在边栏搜索框中对本站进行检索，以获取相关信息。"},{"title":"","date":"2019-07-16T08:15:37.500Z","updated":"2019-07-16T08:15:37.500Z","comments":true,"path":"about/index.html","permalink":"https://SarkerAllen.github.io/about/index.html","excerpt":"","text":"关于我爱好 喜欢计算机 喜欢编程 喜欢自由 喜欢挑战权威 喜欢运动 关于 Email ： serkerallen@163.com 微博 ：https://weibo.com/sarker Github ：https://github.com/SarkerAllen"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-07-16T05:38:25.841Z","updated":"2019-07-16T05:38:25.841Z","comments":true,"path":"2019/07/16/hello-world/","link":"","permalink":"https://SarkerAllen.github.io/2019/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"JavaWeb-Upload","slug":"JavaWeb-upload","date":"2019-07-14T14:07:27.000Z","updated":"2019-07-17T02:49:41.805Z","comments":true,"path":"2019/07/14/JavaWeb-upload/","link":"","permalink":"https://SarkerAllen.github.io/2019/07/14/JavaWeb-upload/","excerpt":"** JavaWeb中的upload** &lt;Excerpt in index | 首页摘要&gt; 一个人如果活着没有梦想,那和咸鱼有什么区别?","text":"** JavaWeb中的upload** &lt;Excerpt in index | 首页摘要&gt; 一个人如果活着没有梦想,那和咸鱼有什么区别? JavaWeb中upload &lt;The rest of contents | 余下全文&gt; JavaWeb中Upload问题解决使用multipart/form-data属性后无法获取参数解决方案 通过js代码解决 123456789101112131415&lt;form id=\"upload\" name=\"upload\" action=\"fileftp.jsp\" method=\"post\" ENCTYPE=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"otherName\" id=\"otherName\" value=\"abcdefg\"&gt; &lt;td nowrap&gt; &lt;input type=\"file\" id=\"file1\" name=\"file1\" value=\"\" size=\"40\" class=\"sbttn\"&gt; &lt;input type=\"submit\" value=\"upload\" class=\"sbttn\"&gt; &lt;/td&gt;&lt;/form&gt;&lt;script language=\"javascript\"&gt; function formSubmit()&#123; var action = \"fileftp.jsp\"; action += \"?otherName=\" + document.upload.otherName.value; document.upload.action = action; document.upload.submit(); &#125;&lt;/script&gt; 通过修改服务器端代码。利用jar包 commons-fileupload-1.2.2.jar和commons-io-1.4.jar 1234567891011121314151617//创建工厂//工厂类可以设置很多对上传文件的限制内容DiskFileItemFactory factory = new DiskFileItemFactory();//创建解析器ServletFileUpload sfu = new ServletFileUpload(factory);sfu.setSizeMax(intsize);//设置文件中的大小也可以设置单个文件的大小//解析requesttry&#123; List&lt;FileItem&gt; list = sfu.parseRequest(request); for(FileItem fileitem : list)&#123; if(fileitem.isFormField())&#123; //FileItem类型的对象里有一个方法isFormField(),可以判断表单项是表单域还是文件域 String name = fileitem.getFildName(); String value = fileitem.getString(); &#125; &#125;&#125; commons-fileUpload.jar 12public DiskFileItemFactory()public DiskFileItemFactory(int sizeThreshold, File repository) sizeThreshold:服务器内存，资源有限限制：sizeThreshold临界值，600KB 上传的文件，如果小于600KB，则把接受到的整个文件放在内存中，程序直接从内存中读取，如果文件大于600KB，则把传过来的文件分成很多部分放在磁盘上的某个零时文件夹，程序需要文件时就去内存和临时文件夹里的临时文件中去读取repository：配置临时文件夹的位置 1void setSizeThreshold(int sizeThreshold) Apache文件上传组件在解析上传数据中的每个字段内容时，需要临时保存解析出的数据，以便在后面进行数据的进一步处理(保存在磁盘特定位置或插入数据库)。 因为Java虚拟机默认可以使用的内存空间时有限的，超出限制时将会抛出“java.lang.OutOfMemoryError”错误。 如果上传的文件很大，例如800M的文件，在内存中将无法临时保存该文件内容，Apache文件上传组件转而采用临时文件来保存这些数据；但如果上传文件的问价很小，例如600个子节的文件，显然将其直接保存在内存中性能会更好一些sizeSizeThreshold方法用于设置是否将上传文件以临时问价的形式保存在磁盘的临界值(以子节为单位的int值)， 如果从没有调用该方法设置此临界值，将会采用系统的默认值10KB。对应的getSizeThreshold()方法来获取此临界值 1void setRepository(File repository) setRepositoryPath方法用于设置当上传文件尺寸大于setSizeThreshold方法设置的临界值时，将文件以临时文件形式保存在磁盘上的存放目录。有一个对应的获得临时文件夹的File getRespository()方法注意：当没有调用此方法设置临时文件存储目录时，默认采用系统默认的临时文件路径，可以通过系统属性java.io.tmpdir 获取。如下代码： 1System.getProperty(\"java.io.tmpdir\"); Tomcat服务器默认临时目录为“&lt;tomcat安装目录&gt;/temp/” FileItem类的常用方法： 1boolean isFormField() isFormField方法用于判断FileItem类对象封装的数据是一个普通文本表单字段，还是一个文件表单字段，如果是普通表单字段则放回true，否则返回false。因此，可以使用该方法判断是否为普通表单域，还是文件上传域。 1String getName() getName方法用于获得文件上传字段中的文件名。 注意 IE或FireFox中获取的文件名是不一样的，IE中式绝对路径，FireFox中只是文件名 1String getFieldName() getFieldName方法用于返回表单标签name属性的值。如上例中&lt;input type=”text” name=”column”&gt;的value 1void write(File file) write方法用于将FileItem对象中保存的主体内容保存到某个指定的文件中。如果FileItem对象中的主体内容是保存在某个临时文件中，该方法顺利完成后，临时文件有可能会被清楚。该方法也可将普通表单字段内容写如多一个文件中，但它主要用途是将上传的文件内容保存在本地文件系统中。 1String getString() getString方法用于将FileItem对象中保存的数据流内容以一个字符串返回，它有两个重载的定义形式： public java.lang.String getString() public java.lang.String getString(java.lang.String encoding) 前者使用缺省的字符集编码将主体内容转换成字符串，后者使用参数指定的字符集编码将主体内容转换成字符串。如果在读取普通表单字段元素的内容是出现了中文乱码现象，请调用第二个getString方法，并为之传递正确的字符集编码名称。 1String getContentType() getContentType方法用于获得上传文件的类型，即表单字段元素描述头属性“Content-Type”的值，如果“image/jpeg”。如果FileItem类对象对应的是普通表单字段，该方法将返回null。 1boolean isInMemory() isInMemoory方法用来判断FileItem对象封装的数据内容是存储在内存中，还是存储在临时文件中，如果存储在内存中则返回true，否则返回false 1void delete() delete方法用来清空FileItem类对象中存放的主体内容，如果主体内容被保存在临时文件中，delete方法将删除该临时文件 尽管当FileItem对象被垃圾收集器收集时会自动清楚临时文件，但及时调用delete方法可以更早的清除临时文件，释放系统存储资源。另外，当系统出现异常时，仍然可能造成有的临时文件被永久保存在了硬盘中。 1InputStream getInputStream() 以流的形式返回上传文件的数据内容 1long getSize() 返回该上传文件的大小（以子节为单位） 上传文件注意项： 为保证服务器安全，上传问价应该放在外界无法直接访问的目录下，比如放于WEB-INF目录下。 为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。 为防止一个目录下出现太多文件，要使用hash算法打散存储。 要限制上传文件的最大值 要限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。 基本思路 获取和创建保存文件的最终目录和临时目录 创建一个DiskFileItemFactory工厂 创建一个文件上传解析器 判断提交上来的数据是否是上传表单的数据，是不是Multipart编码方式ServletFileUpload.isMultipartContext(request) 使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List集合 判断普通域还是文件域 将普通表单域的键值对显示出来 验证后缀的合法性 将文件流写入保存的目录中(生成新的文件名，避免一个目录中文件太多而生成新的存储目录)","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode算法实现——709","slug":"LeetCode_709","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:43:23.521Z","comments":true,"path":"2019/05/13/LeetCode_709/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_709/","excerpt":"** LeetCode——709** &lt;Excerpt in index | 首页摘要&gt; LeetCode——709算法C语言与Java语言实现","text":"** LeetCode——709** &lt;Excerpt in index | 首页摘要&gt; LeetCode——709算法C语言与Java语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_709_To Lower Case实现步骤1.获取传入参数(字符数组) 2.将字符串拆分为字符数组 3.判断字母是否为大写 4.根据大小写之间ASCII值的关系进行转换 5.返回改变后的字符代码实现C语言12345678910char * toLowerCase(char * str)&#123; char *p = str; while(*p != '\\0')&#123; if(*p &gt;= 'A' &amp;&amp; *p &lt;= 'Z')&#123; *P += 32; &#125; *p++; &#125; return str;&#125; Java12345public class Solution&#123; public String toLowerCase(String str)&#123; return str.toLowerCase(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode算法实现","slug":"LeetCode_1021","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:33:55.982Z","comments":true,"path":"2019/05/13/LeetCode_1021/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_1021/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——1021","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——1021 &lt;The rest of contents | 余下全文&gt; LeetCode_1021_Remove Outermost Parentheses实现步骤1.计算字符串的长度，如果长度等于0或长度不是偶数返回&quot;&quot; 2.判断字符串开头是否为&apos;(&apos;，如果不是返回&quot;&quot; 3.创建一个变量A(result)，用于返回计算结果 4.循环遍历字符串，如果是&apos;(&apos;,count++,否则count-- 5.如果count大于等于2时将字符可写入改为true，如果count等于0时将字符可写入改为false 6.将可写入位置的字符赋值给变量A(result) 7.将变量A(result)末尾位置赋值为&apos;\\0&apos;代码实现C语言123456789101112131415161718192021222324252627282930313233343536char * removeOuterParentheses(char * S)&#123; int len = strlen(S); if(len == 0)&#123; return \"\"; &#125; if(len % 2)&#123; return \"\"; &#125; if(S[i] != '(')&#123; return \"\"; &#125; char * result = (char *)malloc(len); int flag = 0; int count = 0; int j = 0 for(int i = 0; i &lt; len; i++)&#123; if(S[i] == '(')&#123; count++; &#125; else if(S[i] == ')')&#123; count--; &#125; if(count == 0)&#123; flag = 0; &#125; else if(count &gt;= 2)&#123; flag = 1; &#125; if(flag)&#123; result[j] = S[i]; j++; &#125; &#125; result[j] = '\\0'; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode_804_题目解答","slug":"LeetCode_804","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:27:43.859Z","comments":true,"path":"2019/05/13/LeetCode_804/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_804/","excerpt":"** LeetCode——804** &lt;Excerpt in index | 首页摘要&gt; LeetCode——804——题目分析与C语言实现","text":"** LeetCode——804** &lt;Excerpt in index | 首页摘要&gt; LeetCode——804——题目分析与C语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_804_Unique Morse Code Words实现步骤1.建立Morse对照数组 2.声明一个数组用于存放一个字符串的Morse对应编码 3.声明一个数组用于存放重复的Morse码 4.将字符串逐个转化为Morse码 5.将字符串的Morse码与数组中的每一个Morse码对比，如果相同则退出比较，如果该Morse码不存在与数组中，则将该Morse码添加至该数组代码实现(C语言)123456789101112131415161718192021222324252627int uniqueMorseRepresentations(char ** words, int wordsSize)&#123; char morse[][5]=&#123;\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\", \"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"&#125;; int i, j, k, find, count = 0; char string[100]; char unique[100][100] = &#123;\"\"&#125;; for(i = 0; i &lt; wordsSize; i++)&#123; j = 0; strcpy(string, \"\"); while(words[i][j])&#123; strcat(string, morse[words[i][j++] - 'a']); &#125; find = 0; for(k = 0; k &lt; count; k++)&#123; if(strcmp(string, unique[k]) == 0)&#123; find = 1; &#125; &#125; if(!find)&#123; strcpy(unique[count++], string); &#125; &#125; return count;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode算法实现","slug":"LeetCode_961","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:43:57.416Z","comments":true,"path":"2019/05/13/LeetCode_961/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_961/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; LeetCode——961算法实现之C语言","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; LeetCode——961算法实现之C语言 &lt;The rest of contents | 余下全文&gt; LeetCode_961_N-Repeated Element in Size 2N Array题目描述在2n大小的数组a中，有n+1个唯一元素，其中一个元素重复n次。实现步骤方法一从数组的第三个元素开始，逐个与第1、2个元素比较，如果相等返回相等的值方法二1.定义三个变量，将数组的前三个元素分别赋给三个变量 2.判断数组的长度是否为4并且第一个元素与第四个元素相等 3.判断第一个元素与第二个或与第三个是否相等 4.判断第二个元素与第三个元素是否相等 5.将数组新元素重新赋给变量，重复3、4代码实现C语言1234567int repeatedNTimes(int* A, int ASize)&#123; for(int i = 2; i &lt; ASize; i++)&#123; if(A[i] == A[i - 1] || A[i] == A[i - 2]) return A[i]; &#125; return -1;&#125; Java语言12345678910111213141516171819public int repeatedNTimes(int[] A) &#123; int a = A[0]; int b = A[1]; int c = A[2]; int i = 3; if(A.length == 4 &amp;&amp; a == A[3]) return a; do&#123; if(a == b || a == c) return a; if(b == c) return b; a = b; b = c; c = A[i]; i++; &#125;while(i &lt;= A.length); return -1;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode——题目905","slug":"LeetCode_905","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:29:10.293Z","comments":true,"path":"2019/05/13/LeetCode_905/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_905/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——905算法","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——905算法 &lt;The rest of contents | 余下全文&gt; LeetCode_905_Sort Array By Parity实现步骤1.双向遍历数组 2.如果头指针指向的数字时奇数，尾指针指向的数字是偶数则交换两数位置 3.如果头指针指向的数字是偶数，尾指针指向的数字是奇数或者头指针和尾指针指向的数字都是奇数则不交换数字，尾指针向前移动一位 4.如果不符合2、3则头指针向后移动一位 5.返回修改后的数组代码实现(C语言)1234567891011121314151617181920int* sortArrayByParity(int* A, int ASize, int* resultSize)&#123; int *head = A; int *foot = A + (ASize - 1); int *temp = (int *)malloc(sizeof(int)); while(head &gt; foot)&#123; if(*head % 2 == 1 &amp;&amp; *foot % 2 == 0)&#123; *temp = *head; *head = *foot; *foot = *temp; head++; foot--; &#125; else if((*head % 2 == 0 &amp;&amp; *head % 2 == 1) || (*head % 2 == 1 &amp;&amp; *foot % 2 == 1)) foot--; else head++; &#125; *resultSize = ASize; return A;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode——938算法","slug":"LeetCode_938","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:30:46.709Z","comments":true,"path":"2019/05/13/LeetCode_938/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_938/","excerpt":"** LeetCode题目解答** &lt;Excerpt in index | 首页摘要&gt; LeetCode——938题目C语言实现","text":"** LeetCode题目解答** &lt;Excerpt in index | 首页摘要&gt; LeetCode——938题目C语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_938_Range Sum of BST实现步骤1.遍历二叉树 2.如果val&lt;L,则遍历另一个节点 3.如果val&gt;R,则遍历另一个节点 4.如果val&gt;L&amp;&amp;val&lt;R,则sum+=val,然后遍历此节点的子节点代码实现（C语言）节点结构12345struct TreeNode&#123; int val; struct TreeNode* left; struct TreeNode* right;&#125;; 算法实现123456789101112131415161718int rangeSumBST(struct TreeNode* root, int L, int R)&#123; if(!root)&#123; return 0; &#125; int sum = 0; if(root-&gt;val &lt; L)&#123; sum += rangeSumBST(root-&gt;right, L, R); &#125; else if(root-&gt;val &gt; R)&#123; sum += rangeSumBST(root-&gt;left, L, R); &#125; else&#123; sum += root-&gt;val; sum += rangeSumBST(root-&gt;left, L, R); sum += rangeSumBST(root-&gt;right, L, R); &#125; return sum;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"java和javascript日期详解","slug":"java-date","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:02:39.261Z","comments":true,"path":"2019/05/13/java-date/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/java-date/","excerpt":"** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt; java的各种日期转换","text":"** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt; java的各种日期转换 &lt;The rest of contents | 余下全文&gt; 日期表示类型 获取long类型的日期格式 1234long time = System.currentTimeMillis();System.out.printf(time+\"\");Date date =new Date();System.out.println(date.getTime()); 获取制定格式的日期 123SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");Date date =new Date();System.out.println(sdf.format(date) ); 把制定格式的日期转为date或者毫秒值 123SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");Date date = sdf.parse(\"2016-05-22 10:15:21\");long mills = date.getTime(); 说明:System.currentTimeMillis()并不能精确到1ms的级别,它取决于运行的系统,你再windows,mac,linux精确的范围都有差异,对于有高精度时间的要求,不能使用这个 日期计算 最方便的方式是将时间转为毫秒值进行计算1234Date from =new Date();Thread.sleep(200);//线程休眠2msDate to =new Date();System.out.println(to.getTime()-from.getTime()); 高精度时间12long time1 =System.nanoTime();System.out.printf(time1+\"\"); 说明:System.nanoTime()提高了ns级别的精度,1ms=1000000ns, javascript日期 获取时间的毫秒值，获取月份，时间 1234567891011121314var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间 时间戳获取注意，java，php等生成的时间戳是秒，不是毫秒，所以需要签名时间戳的时候，需要转为秒时间戳 12var time = new Date();var timestamp = parseInt(time.getTime()/1000); 格式化时间 12345678910111213141516//获取当前时间，格式YYYY-MM-DDfunction getNowFormatDate() &#123; var date = new Date(); var seperator1 = \"-\"; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = \"0\" + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = \"0\" + strDate; &#125; var currentdate = year + seperator1 + month + seperator1 + strDate; return currentdate;&#125;","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]}]}
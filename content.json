{"meta":{"title":"Kevin's Blog","subtitle":"Kevin的技术分享","description":"小白的学习之路","author":"Kevin","url":"https://SarkerAllen.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-07-17T13:37:08.144Z","updated":"2018-07-24T01:49:56.000Z","comments":false,"path":"/404.html","permalink":"https://SarkerAllen.github.io//404.html","excerpt":"","text":".article-title { font-size: 2.1em; } strong a { color: #747474; } .share { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .search2 { height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; } .search2:hover { opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) }; .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } 很抱歉，您所访问的地址并不存在: 回主页 · 所有文章 · 留言板 可在边栏搜索框中对本站进行检索，以获取相关信息。"},{"title":"","date":"2019-07-16T08:15:37.500Z","updated":"2019-07-16T08:15:37.500Z","comments":true,"path":"about/index.html","permalink":"https://SarkerAllen.github.io/about/index.html","excerpt":"","text":"关于我爱好 喜欢计算机 喜欢编程 喜欢自由 喜欢挑战权威 喜欢运动 关于 Email ： serkerallen@163.com 微博 ：https://weibo.com/sarker Github ：https://github.com/SarkerAllen"},{"title":"","date":"2019-07-17T15:25:40.257Z","updated":"2019-07-17T15:25:40.257Z","comments":true,"path":"friends/index.html","permalink":"https://SarkerAllen.github.io/friends/index.html","excerpt":"","text":"微博：https://weibo.com/sarker Github：https://github.com/SarkerAllen"}],"posts":[{"title":"设计模式——单例模式(浅谈)","slug":"Singleton","date":"2019-07-18T15:15:14.000Z","updated":"2019-07-18T16:00:37.452Z","comments":true,"path":"2019/07/18/Singleton/","link":"","permalink":"https://SarkerAllen.github.io/2019/07/18/Singleton/","excerpt":"浅谈单例设计模式: &lt;Excerpt in index | 首页摘要&gt; 单例设计模式以及java语言简单实现","text":"浅谈单例设计模式: &lt;Excerpt in index | 首页摘要&gt; 单例设计模式以及java语言简单实现 &lt;The rest of contents | 余下全文&gt; 单例设计模式(浅谈)什么是设计模式 (Design Pattern)设计模式是一套被人反复使用、多数人知晓、经过分类的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络。 单例模式 (Singleton) 最常用的、最简单的设计模式单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。保证在整个应用中某一个类有且只有一个实例(一个类在内存中只存在一个对象)，即所有的指向该类型实例的引用都指向同一块内存空间。 单例设计模式实现的步骤: 必须在类中自己先创建一个对象 私用自身的构造器，防止外界通过构造器创建新的对象 向外提供一个公共静态方法用于获取自身的对象 代码实现: 饿汉式 1234567public class SingletonDemo&#123; private static SingletonDemo singleton = new SingletonDemo(); private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; return singleton; &#125;&#125; ​ 懒汉式(存在线程不安全) 12345678910public class SingletonDemo&#123; private static SingletonDemo singleton; private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; if(singleton == null)&#123; singleton = new SingletonDemo(); &#125; return singleton; &#125;&#125; 关于懒汉式单例模式线程安全的解决方案双重检查锁可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。 什么使双重检查加锁机制所谓双重加锁机制，指的是：并不是每一个进入getInstance方法都需要同步，而使先不同步，进入方法后先检查是否存在实例，如果不存在才进行下面的同步块，只是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。 双重检查锁加锁机制实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。 注意：在Java1.4及以前的版本中，很多jvm对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只能用Java5以上的版本。 提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但是并不建议大量采用。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://SarkerAllen.github.io/categories/设计模式/"}],"tags":[{"name":"singleton","slug":"singleton","permalink":"https://SarkerAllen.github.io/tags/singleton/"}]},{"title":"JavaWeb-Upload","slug":"JavaWeb-upload","date":"2019-07-14T14:07:27.000Z","updated":"2019-07-17T02:49:41.805Z","comments":true,"path":"2019/07/14/JavaWeb-upload/","link":"","permalink":"https://SarkerAllen.github.io/2019/07/14/JavaWeb-upload/","excerpt":"** JavaWeb中的upload** &lt;Excerpt in index | 首页摘要&gt; 一个人如果活着没有梦想,那和咸鱼有什么区别?","text":"** JavaWeb中的upload** &lt;Excerpt in index | 首页摘要&gt; 一个人如果活着没有梦想,那和咸鱼有什么区别? JavaWeb中upload &lt;The rest of contents | 余下全文&gt; JavaWeb中Upload问题解决使用multipart/form-data属性后无法获取参数解决方案 通过js代码解决 123456789101112131415&lt;form id=\"upload\" name=\"upload\" action=\"fileftp.jsp\" method=\"post\" ENCTYPE=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"otherName\" id=\"otherName\" value=\"abcdefg\"&gt; &lt;td nowrap&gt; &lt;input type=\"file\" id=\"file1\" name=\"file1\" value=\"\" size=\"40\" class=\"sbttn\"&gt; &lt;input type=\"submit\" value=\"upload\" class=\"sbttn\"&gt; &lt;/td&gt;&lt;/form&gt;&lt;script language=\"javascript\"&gt; function formSubmit()&#123; var action = \"fileftp.jsp\"; action += \"?otherName=\" + document.upload.otherName.value; document.upload.action = action; document.upload.submit(); &#125;&lt;/script&gt; 通过修改服务器端代码。利用jar包 commons-fileupload-1.2.2.jar和commons-io-1.4.jar 1234567891011121314151617//创建工厂//工厂类可以设置很多对上传文件的限制内容DiskFileItemFactory factory = new DiskFileItemFactory();//创建解析器ServletFileUpload sfu = new ServletFileUpload(factory);sfu.setSizeMax(intsize);//设置文件中的大小也可以设置单个文件的大小//解析requesttry&#123; List&lt;FileItem&gt; list = sfu.parseRequest(request); for(FileItem fileitem : list)&#123; if(fileitem.isFormField())&#123; //FileItem类型的对象里有一个方法isFormField(),可以判断表单项是表单域还是文件域 String name = fileitem.getFildName(); String value = fileitem.getString(); &#125; &#125;&#125; commons-fileUpload.jar 12public DiskFileItemFactory()public DiskFileItemFactory(int sizeThreshold, File repository) sizeThreshold:服务器内存，资源有限限制：sizeThreshold临界值，600KB 上传的文件，如果小于600KB，则把接受到的整个文件放在内存中，程序直接从内存中读取，如果文件大于600KB，则把传过来的文件分成很多部分放在磁盘上的某个零时文件夹，程序需要文件时就去内存和临时文件夹里的临时文件中去读取repository：配置临时文件夹的位置 1void setSizeThreshold(int sizeThreshold) Apache文件上传组件在解析上传数据中的每个字段内容时，需要临时保存解析出的数据，以便在后面进行数据的进一步处理(保存在磁盘特定位置或插入数据库)。 因为Java虚拟机默认可以使用的内存空间时有限的，超出限制时将会抛出“java.lang.OutOfMemoryError”错误。 如果上传的文件很大，例如800M的文件，在内存中将无法临时保存该文件内容，Apache文件上传组件转而采用临时文件来保存这些数据；但如果上传文件的问价很小，例如600个子节的文件，显然将其直接保存在内存中性能会更好一些sizeSizeThreshold方法用于设置是否将上传文件以临时问价的形式保存在磁盘的临界值(以子节为单位的int值)， 如果从没有调用该方法设置此临界值，将会采用系统的默认值10KB。对应的getSizeThreshold()方法来获取此临界值 1void setRepository(File repository) setRepositoryPath方法用于设置当上传文件尺寸大于setSizeThreshold方法设置的临界值时，将文件以临时文件形式保存在磁盘上的存放目录。有一个对应的获得临时文件夹的File getRespository()方法注意：当没有调用此方法设置临时文件存储目录时，默认采用系统默认的临时文件路径，可以通过系统属性java.io.tmpdir 获取。如下代码： 1System.getProperty(\"java.io.tmpdir\"); Tomcat服务器默认临时目录为“&lt;tomcat安装目录&gt;/temp/” FileItem类的常用方法： 1boolean isFormField() isFormField方法用于判断FileItem类对象封装的数据是一个普通文本表单字段，还是一个文件表单字段，如果是普通表单字段则放回true，否则返回false。因此，可以使用该方法判断是否为普通表单域，还是文件上传域。 1String getName() getName方法用于获得文件上传字段中的文件名。 注意 IE或FireFox中获取的文件名是不一样的，IE中式绝对路径，FireFox中只是文件名 1String getFieldName() getFieldName方法用于返回表单标签name属性的值。如上例中&lt;input type=”text” name=”column”&gt;的value 1void write(File file) write方法用于将FileItem对象中保存的主体内容保存到某个指定的文件中。如果FileItem对象中的主体内容是保存在某个临时文件中，该方法顺利完成后，临时文件有可能会被清楚。该方法也可将普通表单字段内容写如多一个文件中，但它主要用途是将上传的文件内容保存在本地文件系统中。 1String getString() getString方法用于将FileItem对象中保存的数据流内容以一个字符串返回，它有两个重载的定义形式： public java.lang.String getString() public java.lang.String getString(java.lang.String encoding) 前者使用缺省的字符集编码将主体内容转换成字符串，后者使用参数指定的字符集编码将主体内容转换成字符串。如果在读取普通表单字段元素的内容是出现了中文乱码现象，请调用第二个getString方法，并为之传递正确的字符集编码名称。 1String getContentType() getContentType方法用于获得上传文件的类型，即表单字段元素描述头属性“Content-Type”的值，如果“image/jpeg”。如果FileItem类对象对应的是普通表单字段，该方法将返回null。 1boolean isInMemory() isInMemoory方法用来判断FileItem对象封装的数据内容是存储在内存中，还是存储在临时文件中，如果存储在内存中则返回true，否则返回false 1void delete() delete方法用来清空FileItem类对象中存放的主体内容，如果主体内容被保存在临时文件中，delete方法将删除该临时文件 尽管当FileItem对象被垃圾收集器收集时会自动清楚临时文件，但及时调用delete方法可以更早的清除临时文件，释放系统存储资源。另外，当系统出现异常时，仍然可能造成有的临时文件被永久保存在了硬盘中。 1InputStream getInputStream() 以流的形式返回上传文件的数据内容 1long getSize() 返回该上传文件的大小（以子节为单位） 上传文件注意项： 为保证服务器安全，上传问价应该放在外界无法直接访问的目录下，比如放于WEB-INF目录下。 为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。 为防止一个目录下出现太多文件，要使用hash算法打散存储。 要限制上传文件的最大值 要限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。 基本思路 获取和创建保存文件的最终目录和临时目录 创建一个DiskFileItemFactory工厂 创建一个文件上传解析器 判断提交上来的数据是否是上传表单的数据，是不是Multipart编码方式ServletFileUpload.isMultipartContext(request) 使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List集合 判断普通域还是文件域 将普通表单域的键值对显示出来 验证后缀的合法性 将文件流写入保存的目录中(生成新的文件名，避免一个目录中文件太多而生成新的存储目录)","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode算法实现","slug":"LeetCode_1021","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:33:55.982Z","comments":true,"path":"2019/05/13/LeetCode_1021/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_1021/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——1021","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——1021 &lt;The rest of contents | 余下全文&gt; LeetCode_1021_Remove Outermost Parentheses实现步骤1.计算字符串的长度，如果长度等于0或长度不是偶数返回&quot;&quot; 2.判断字符串开头是否为&apos;(&apos;，如果不是返回&quot;&quot; 3.创建一个变量A(result)，用于返回计算结果 4.循环遍历字符串，如果是&apos;(&apos;,count++,否则count-- 5.如果count大于等于2时将字符可写入改为true，如果count等于0时将字符可写入改为false 6.将可写入位置的字符赋值给变量A(result) 7.将变量A(result)末尾位置赋值为&apos;\\0&apos;代码实现C语言123456789101112131415161718192021222324252627282930313233343536char * removeOuterParentheses(char * S)&#123; int len = strlen(S); if(len == 0)&#123; return \"\"; &#125; if(len % 2)&#123; return \"\"; &#125; if(S[i] != '(')&#123; return \"\"; &#125; char * result = (char *)malloc(len); int flag = 0; int count = 0; int j = 0 for(int i = 0; i &lt; len; i++)&#123; if(S[i] == '(')&#123; count++; &#125; else if(S[i] == ')')&#123; count--; &#125; if(count == 0)&#123; flag = 0; &#125; else if(count &gt;= 2)&#123; flag = 1; &#125; if(flag)&#123; result[j] = S[i]; j++; &#125; &#125; result[j] = '\\0'; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode算法实现——709","slug":"LeetCode_709","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:43:23.521Z","comments":true,"path":"2019/05/13/LeetCode_709/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_709/","excerpt":"** LeetCode——709** &lt;Excerpt in index | 首页摘要&gt; LeetCode——709算法C语言与Java语言实现","text":"** LeetCode——709** &lt;Excerpt in index | 首页摘要&gt; LeetCode——709算法C语言与Java语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_709_To Lower Case实现步骤1.获取传入参数(字符数组) 2.将字符串拆分为字符数组 3.判断字母是否为大写 4.根据大小写之间ASCII值的关系进行转换 5.返回改变后的字符代码实现C语言12345678910char * toLowerCase(char * str)&#123; char *p = str; while(*p != '\\0')&#123; if(*p &gt;= 'A' &amp;&amp; *p &lt;= 'Z')&#123; *P += 32; &#125; *p++; &#125; return str;&#125; Java12345public class Solution&#123; public String toLowerCase(String str)&#123; return str.toLowerCase(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode——题目905","slug":"LeetCode_905","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:29:10.293Z","comments":true,"path":"2019/05/13/LeetCode_905/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_905/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——905算法","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——905算法 &lt;The rest of contents | 余下全文&gt; LeetCode_905_Sort Array By Parity实现步骤1.双向遍历数组 2.如果头指针指向的数字时奇数，尾指针指向的数字是偶数则交换两数位置 3.如果头指针指向的数字是偶数，尾指针指向的数字是奇数或者头指针和尾指针指向的数字都是奇数则不交换数字，尾指针向前移动一位 4.如果不符合2、3则头指针向后移动一位 5.返回修改后的数组代码实现(C语言)1234567891011121314151617181920int* sortArrayByParity(int* A, int ASize, int* resultSize)&#123; int *head = A; int *foot = A + (ASize - 1); int *temp = (int *)malloc(sizeof(int)); while(head &gt; foot)&#123; if(*head % 2 == 1 &amp;&amp; *foot % 2 == 0)&#123; *temp = *head; *head = *foot; *foot = *temp; head++; foot--; &#125; else if((*head % 2 == 0 &amp;&amp; *head % 2 == 1) || (*head % 2 == 1 &amp;&amp; *foot % 2 == 1)) foot--; else head++; &#125; *resultSize = ASize; return A;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode——938算法","slug":"LeetCode_938","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:30:46.709Z","comments":true,"path":"2019/05/13/LeetCode_938/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_938/","excerpt":"** LeetCode题目解答** &lt;Excerpt in index | 首页摘要&gt; LeetCode——938题目C语言实现","text":"** LeetCode题目解答** &lt;Excerpt in index | 首页摘要&gt; LeetCode——938题目C语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_938_Range Sum of BST实现步骤1.遍历二叉树 2.如果val&lt;L,则遍历另一个节点 3.如果val&gt;R,则遍历另一个节点 4.如果val&gt;L&amp;&amp;val&lt;R,则sum+=val,然后遍历此节点的子节点代码实现（C语言）节点结构12345struct TreeNode&#123; int val; struct TreeNode* left; struct TreeNode* right;&#125;; 算法实现123456789101112131415161718int rangeSumBST(struct TreeNode* root, int L, int R)&#123; if(!root)&#123; return 0; &#125; int sum = 0; if(root-&gt;val &lt; L)&#123; sum += rangeSumBST(root-&gt;right, L, R); &#125; else if(root-&gt;val &gt; R)&#123; sum += rangeSumBST(root-&gt;left, L, R); &#125; else&#123; sum += root-&gt;val; sum += rangeSumBST(root-&gt;left, L, R); sum += rangeSumBST(root-&gt;right, L, R); &#125; return sum;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode_804_题目解答","slug":"LeetCode_804","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:27:43.859Z","comments":true,"path":"2019/05/13/LeetCode_804/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_804/","excerpt":"** LeetCode——804** &lt;Excerpt in index | 首页摘要&gt; LeetCode——804——题目分析与C语言实现","text":"** LeetCode——804** &lt;Excerpt in index | 首页摘要&gt; LeetCode——804——题目分析与C语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_804_Unique Morse Code Words实现步骤1.建立Morse对照数组 2.声明一个数组用于存放一个字符串的Morse对应编码 3.声明一个数组用于存放重复的Morse码 4.将字符串逐个转化为Morse码 5.将字符串的Morse码与数组中的每一个Morse码对比，如果相同则退出比较，如果该Morse码不存在与数组中，则将该Morse码添加至该数组代码实现(C语言)123456789101112131415161718192021222324252627int uniqueMorseRepresentations(char ** words, int wordsSize)&#123; char morse[][5]=&#123;\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\", \"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"&#125;; int i, j, k, find, count = 0; char string[100]; char unique[100][100] = &#123;\"\"&#125;; for(i = 0; i &lt; wordsSize; i++)&#123; j = 0; strcpy(string, \"\"); while(words[i][j])&#123; strcat(string, morse[words[i][j++] - 'a']); &#125; find = 0; for(k = 0; k &lt; count; k++)&#123; if(strcmp(string, unique[k]) == 0)&#123; find = 1; &#125; &#125; if(!find)&#123; strcpy(unique[count++], string); &#125; &#125; return count;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode算法实现","slug":"LeetCode_961","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:43:57.416Z","comments":true,"path":"2019/05/13/LeetCode_961/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_961/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; LeetCode——961算法实现之C语言","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; LeetCode——961算法实现之C语言 &lt;The rest of contents | 余下全文&gt; LeetCode_961_N-Repeated Element in Size 2N Array题目描述在2n大小的数组a中，有n+1个唯一元素，其中一个元素重复n次。实现步骤方法一从数组的第三个元素开始，逐个与第1、2个元素比较，如果相等返回相等的值方法二1.定义三个变量，将数组的前三个元素分别赋给三个变量 2.判断数组的长度是否为4并且第一个元素与第四个元素相等 3.判断第一个元素与第二个或与第三个是否相等 4.判断第二个元素与第三个元素是否相等 5.将数组新元素重新赋给变量，重复3、4代码实现C语言1234567int repeatedNTimes(int* A, int ASize)&#123; for(int i = 2; i &lt; ASize; i++)&#123; if(A[i] == A[i - 1] || A[i] == A[i - 2]) return A[i]; &#125; return -1;&#125; Java语言12345678910111213141516171819public int repeatedNTimes(int[] A) &#123; int a = A[0]; int b = A[1]; int c = A[2]; int i = 3; if(A.length == 4 &amp;&amp; a == A[3]) return a; do&#123; if(a == b || a == c) return a; if(b == c) return b; a = b; b = c; c = A[i]; i++; &#125;while(i &lt;= A.length); return -1;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"java和javascript日期详解","slug":"java-date","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:02:39.261Z","comments":true,"path":"2019/05/13/java-date/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/java-date/","excerpt":"** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt; java的各种日期转换","text":"** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt; java的各种日期转换 &lt;The rest of contents | 余下全文&gt; 日期表示类型 获取long类型的日期格式 1234long time = System.currentTimeMillis();System.out.printf(time+\"\");Date date =new Date();System.out.println(date.getTime()); 获取制定格式的日期 123SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");Date date =new Date();System.out.println(sdf.format(date) ); 把制定格式的日期转为date或者毫秒值 123SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");Date date = sdf.parse(\"2016-05-22 10:15:21\");long mills = date.getTime(); 说明:System.currentTimeMillis()并不能精确到1ms的级别,它取决于运行的系统,你再windows,mac,linux精确的范围都有差异,对于有高精度时间的要求,不能使用这个 日期计算 最方便的方式是将时间转为毫秒值进行计算1234Date from =new Date();Thread.sleep(200);//线程休眠2msDate to =new Date();System.out.println(to.getTime()-from.getTime()); 高精度时间12long time1 =System.nanoTime();System.out.printf(time1+\"\"); 说明:System.nanoTime()提高了ns级别的精度,1ms=1000000ns, javascript日期 获取时间的毫秒值，获取月份，时间 1234567891011121314var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间 时间戳获取注意，java，php等生成的时间戳是秒，不是毫秒，所以需要签名时间戳的时候，需要转为秒时间戳 12var time = new Date();var timestamp = parseInt(time.getTime()/1000); 格式化时间 12345678910111213141516//获取当前时间，格式YYYY-MM-DDfunction getNowFormatDate() &#123; var date = new Date(); var seperator1 = \"-\"; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = \"0\" + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = \"0\" + strDate; &#125; var currentdate = year + seperator1 + month + seperator1 + strDate; return currentdate;&#125;","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-31T16:00:00.000Z","updated":"2019-07-18T15:59:36.231Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"https://SarkerAllen.github.io/2019/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
{"meta":{"title":"Kevin's Blog","subtitle":"Kevin的技术分享","description":"小白的学习之路","author":"Kevin","url":"https://SarkerAllen.github.io","root":"/"},"pages":[{"title":"","date":"2019-07-16T08:15:37.500Z","updated":"2019-07-16T08:15:37.500Z","comments":true,"path":"about/index.html","permalink":"https://SarkerAllen.github.io/about/index.html","excerpt":"","text":"关于我爱好 喜欢计算机 喜欢编程 喜欢自由 喜欢挑战权威 喜欢运动 关于 Email ： serkerallen@163.com 微博 ：https://weibo.com/sarker Github ：https://github.com/SarkerAllen"},{"title":"","date":"2019-07-17T15:25:40.257Z","updated":"2019-07-17T15:25:40.257Z","comments":true,"path":"friends/index.html","permalink":"https://SarkerAllen.github.io/friends/index.html","excerpt":"","text":"微博：https://weibo.com/sarker Github：https://github.com/SarkerAllen"},{"title":"404 Not Found：该页无法显示","date":"2019-07-17T13:37:08.144Z","updated":"2018-07-24T01:49:56.000Z","comments":false,"path":"/404.html","permalink":"https://SarkerAllen.github.io//404.html","excerpt":"","text":".article-title { font-size: 2.1em; } strong a { color: #747474; } .share { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .search2 { height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; } .search2:hover { opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) }; .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } 很抱歉，您所访问的地址并不存在: 回主页 · 所有文章 · 留言板 可在边栏搜索框中对本站进行检索，以获取相关信息。"}],"posts":[{"title":"Spring中装配Bean","slug":"spring-bean","date":"2019-08-15T07:48:00.000Z","updated":"2019-08-15T07:45:33.160Z","comments":true,"path":"2019/08/15/spring-bean/","link":"","permalink":"https://SarkerAllen.github.io/2019/08/15/spring-bean/","excerpt":"** Bean的配置** &lt;Excerpt in index | 首页摘要&gt; Spring中bean的配置","text":"** Bean的配置** &lt;Excerpt in index | 首页摘要&gt; Spring中bean的配置 &lt;The rest of contents | 余下全文&gt; Spring装配beanSpring配置的可选方案当描述bean如何装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制: 在XML中进行显式配置 在Java中进行显式配置 隐式的bean发现机制和自动装配 建议：尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显示配置bean的时候，推荐使用类型安全并且比XML更加强大的JavaConfig。只有想使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时才应该使用XML。 自动化装配beanSpring从两个角度来实现自动化装配: 组件扫描(component scanning):Spring会自动发现应用上下文中所创建的bean 自动装配(autowiring):Spring自动满足bean之间的依赖 创建一个可被发现的bean CompactDisc接口 12345package soundsystem;public interface CompactDisc&#123; void play();&#125; 带有@Component注解的CompactDisc实现类SgtPeppers 123456789101112package soundsystem;import org.springframework.stereotype.Component;@Component //声明组建类，并告诉spring要为这个类创建beanpublic class SgtPeppers implements CompactDisc&#123; private String title = \"sgt\"; private String artist = \"The Beatles\"; public void play()&#123; System.out.println(\"Playing \" + title + \" by \" + artist); &#125;&#125; @ComponentScan注解启用组建扫描 12345678package soundsystem;import org.springframework.context.annotation.componentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig&#123;&#125; 通过XML启用组建扫描 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"soundsystem\"/&gt;&lt;/beans&gt; 为组件扫描的bean命名 @Component注解 1234@Component(\"lonelyHeartsClub\")public class SgtPeppers implements CompactDisc&#123; ...&#125; @Named(Java依赖注入规范) 1234567package soundsystem;import javax.inject.Named;@Named(\"lonelyHeartsClub\")public class SgtPeppers implements CompactDisc&#123; ...&#125; 设置组建扫描的基础包 指定不同的基础包 123@Configuration@ComponentScan(basePackages=&#123;\"soundsystem\"&#125;)public class CDPlayerConfig&#123;&#125; 设置多个基础包 123@Configuration@ComponentScan(basePackages=&#123;\"soundsystem\", \"video\"&#125;)public class CDPlayerConfig&#123;&#125; 指定为包中所包含的接口或类 123@Configuration@ComponentScan(basePackageClasses=&#123;CDPlayer.class, DVDPlayer.class&#125;)public class CDPlayerConfig&#123;&#125; 通过为bean添加注解实现自动装配自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。可以借助Spring的@Autowired注解。 1234567891011121314151617181920/* *通过自动装配，将一个CompactDisc注入到CDPlayer之中 */package soundsystem;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CDPlayer implements MediaPlayer&#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; public void play()&#123; cd.play(); &#125;&#125; @Autowired注解不仅能够用在构造器上，还能用在属性的Setter方法上 1234@Autowiredpublic void setCompactDisc(CompactDisc cd)&#123; this.cd = cd;&#125; @Autowired注解可以用在类的任何方法上 不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖的话，那么这个bean将会被装配进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false： 1234@Autowired(required=false)public CDPlayer(CompactDisc cd)&#123; this.cd = cd;&#125; 将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配成功的话，Spring将会让这个bean处于未装配状态。如果有多个bean都满足以来关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。 也可以使用@Inject实现自动装配 12345678910111213package soundsystem;import javax.inject.Inject;import javax.inject.Named;@Namedpublic class CDPlayer&#123; ... @Inject public CDPlayer(CompactDisc cd)&#123; this.cd = cd; &#125; ...&#125;","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://SarkerAllen.github.io/tags/Spring/"}]},{"title":"Java中的泛型","slug":"java-generic","date":"2019-07-20T06:07:08.000Z","updated":"2019-07-20T07:53:05.847Z","comments":true,"path":"2019/07/20/java-generic/","link":"","permalink":"https://SarkerAllen.github.io/2019/07/20/java-generic/","excerpt":"*浅谈Java中的泛型 * &lt;Excerpt in index | 首页摘要&gt; Java中的泛型、泛型类、泛型方法","text":"*浅谈Java中的泛型 * &lt;Excerpt in index | 首页摘要&gt; Java中的泛型、泛型类、泛型方法 &lt;The rest of contents | 余下全文&gt; 泛型为什么使用泛型 存储在集合中的元素，取出来都是Object类型的，此时就得强转 约束存储到集合中的元素必须是相同的数据类型 设计一个点类，来封装坐标位置，要求坐标位置支持String支持integer支持double类型（重复设计） 泛型(Generic Type)从Java5开始支持的新语法 什么是泛型 广泛通用的类型 代码模板中类型不确定，谁调用该段代码，谁指明类型 简单定义 123456789101112131415161718192021222324class Demo&lt;T&gt;&#123; private T x; private T y; public T getX()&#123; return x; &#125; public void setX(T x)&#123; this.x = x; &#125; public T getY&#123; return y; &#125; public void setY(T y)&#123; this.y = y; &#125;&#125;//泛型尖括号中可以使用T:Type E：Element K:Key V:Value//具体是什么类型取决于调用者，不对泛型进行设置默认objectpublic class TestDemo&#123; public static void main(String[]args)&#123; Point&lt;String&gt; p1 = new Point&lt;String&gt;(); Point&lt;Integer&gt; p2 = new Point&lt;Integer&gt;(); &#125;&#125; 泛型类直接在类/接口上定义的类型 泛型类的子类继承泛型类是需要指定类型 使用泛型：保证前后类型一致 12List&lt;String&gt; list = new ArrayList&lt;String&gt;();//该list只能存储String类型的元素 因为前后类型相同，所以Java7开始，推出了泛型的菱形语法&lt;&gt; 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 泛型不存在继承的关系，例如： 1List&lt;Object&gt;list = new ArrayList&lt;String&gt;();//错误的 从此以后，使用集合都得使用泛型来约束该集合中的元素的类型 通过反编译发现：泛型也是语法糖，底层依然使用强制类型转换的方式实现 泛型方法在方法上声明泛型 泛型类中的泛型只能适用于非静态方法，如果需要给静态方法设置泛型，此时使用泛型方法 泛型类中的泛型应该适用于整个类中的多个方法，有时候支队某一个方法设置泛型即可 一般的，把自定义的泛型作为该方法的返回类型才有意义，而且此时的泛型必须是由参数设置进来的，如果没有参数来设置泛型的具体类型，此时的方法一般返回设计为Object即可 代码示例 1234//表示在该方法中使用T来表示一种未知类型public static &lt;T&gt; T Demo(T value)&#123; return value;&#125; 泛型的通配符、上限和下限 泛型的通配符：不知道用什么类型来接收时，此时可以使用？，？表示未知通配符 12345678public class Demo&#123; public static void main(String[]args)&#123; &#125; private static void function(List&lt;?&gt;list)&#123; //此时只能接收数据，不能添加数据至list &#125;&#125; 泛型的上限和下限：用来限定元素的类型必须时X类的子类或相同，X类的父类或相同 12345678//泛型的上限：此时的泛型？必须时Numer类型或Number类的子类public static void function(List&lt;? extends Number&gt; list)&#123; &#125;//泛型的下限：此时的泛型？必须时Number类型或Number类的父类public static void function(List&lt;? super Number&gt;list)&#123; &#125; 泛型的擦除和转换 泛型的擦除： 泛型编译之后就消失了(泛型的自动擦除) 当把带有泛型的集合赋给不带泛型的集合，此时泛型被擦除(手动擦除) 12345678public class Demo&#123; public static void main(String[]args)&#123; List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); list1.add(1); List list2 = null; list2 = list1;//此时泛型擦除 &#125;&#125; 堆污染： 当一个方法既使用泛型的时候也使用可变参数，此时容易导致堆污染问题。 如：在Arrays类中的 asList() 方法","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"浅谈Java中的List、Set与Map集合","slug":"Java-List-Set-Map","date":"2019-07-19T15:30:23.000Z","updated":"2019-07-20T03:49:30.748Z","comments":true,"path":"2019/07/19/Java-List-Set-Map/","link":"","permalink":"https://SarkerAllen.github.io/2019/07/19/Java-List-Set-Map/","excerpt":"*浅谈Java中的List、Set与Map集合 * &lt;Excerpt in index | 首页摘要&gt; Java中的List、Set与Map集合分析","text":"*浅谈Java中的List、Set与Map集合 * &lt;Excerpt in index | 首页摘要&gt; Java中的List、Set与Map集合分析 &lt;The rest of contents | 余下全文&gt; 接口继承关系以及实现集合类存放于Java.util包中，主要有3种：List、Set和Map。 Collection：Collection是集合List、Set、Queue的最基本的接口 Iterator：迭代器，可以通过迭代器遍历集合中的数据 Map：是映射表的基础接口 ListJava的List是非常用的数据类型。List是有序的Collection。Java List一共三个类：分别是ArrayList、Vector和LinkedList。 ArrayListArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足是需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 VectorVector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 LinkedListLinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，它还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 SetSet注重独一无二的性质，该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象的hashCode值(Java是依据对象的内存地址计算出的次序号)判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object和hashCode方法的equals方法。Java Set一共三个实现类：分别是HashSet、TreeSet和LinkHashSet。 HashSet哈希表里边存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序(与List显然不同)而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashCode方法来获取的，HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法，如果equals结果尾true，HashSet就视为同一个元素。如果equals为false就不是同一个元素。 哈希值相同equals为false的元素是怎么存储呢，就是在同样的哈希值下顺延(可以认为哈希值相同的元素放在一个哈希桶中)。也就是哈希一样的存一列。HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置可以存放多个元素。 TreeSet TreeSet()是使用二叉树的原理对add()的对象按照指定的顺序排序(升序、降序)，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置 Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自定义的类必须实现Comparable接口，并且覆写相应的compareTo()方法，才可以正常使用。 在覆写compareTo()方法时，要返回相应的值才能使TreeSet按照一定的规则来排序。 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 LinkedHashSet对于LinkedHashSet而言，它继承于HashSet、又基于LinkedHashMap来实现的。 LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。 MapHashMapHashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法是HashMap具有线程安全的能里，或者使用ConcurrentHashMap。 HashTableHashTable是遗留类，很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写HashTable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。HashTable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 TreeMapTreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是有序的。如果使用排序的映射，建议使用TreeMap。 LinkedHashMapLinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录时先插入的，也可以在构造时带参数。 总结三者的区别 List有序、可以重复，有三个实现类，ArrayList、LinkedList、Vector Set无序、不可重复，有两个实现类，HashSet、LinkedHashSet Map键不可以重复、值可以重复，有三个实现类，HashMap、HashTable、LinkedHashMap List三个子类的区别 ArrayList：底层使用Object[]数组实现，内存地址都是连续的便于索引，查询快；在新增的时候需要申请一块连续的内存空间，所以增删比较慢。 LinkedList：底层是基于链表实现，链表内存是散乱的，在存储自身内存地址的同时，还存储着下一个元素的内存地址，所以查询慢，增删快。 Vector：底层数组实现，由于所有的方法都是采用synchronize，线程安全，效率慢。 Map三个子类的区别 HashMap：基于hash表的Map接口实现，非线程安全，支持键null，值null HashTable：线程安全，不支持键null，值null LinkedHashMap：持两种排序，插入顺序和访问顺序。前者是指按照插入时的顺序排序，后者是指按照最旧使用到最近使用的顺序 Set两个子类的区别 HashSet：底层由HashMap实现 LinkedHashSet：LinkedHashSet继承自HashSet，源码更少、更简单，唯一的区别时LinkedHashSet内部使用的时LinkHashMap。这样做的意义或者好处时LinkedHashSet中的元素顺序是可以保证的，也就是说遍历顺序和插入顺序是一致的。","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"设计模式——单例模式(浅谈)","slug":"Singleton","date":"2019-07-18T15:15:14.000Z","updated":"2019-07-18T16:00:37.452Z","comments":true,"path":"2019/07/18/Singleton/","link":"","permalink":"https://SarkerAllen.github.io/2019/07/18/Singleton/","excerpt":"浅谈单例设计模式: &lt;Excerpt in index | 首页摘要&gt; 单例设计模式以及java语言简单实现","text":"浅谈单例设计模式: &lt;Excerpt in index | 首页摘要&gt; 单例设计模式以及java语言简单实现 &lt;The rest of contents | 余下全文&gt; 单例设计模式(浅谈)什么是设计模式 (Design Pattern)设计模式是一套被人反复使用、多数人知晓、经过分类的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络。 单例模式 (Singleton) 最常用的、最简单的设计模式单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。保证在整个应用中某一个类有且只有一个实例(一个类在内存中只存在一个对象)，即所有的指向该类型实例的引用都指向同一块内存空间。 单例设计模式实现的步骤: 必须在类中自己先创建一个对象 私用自身的构造器，防止外界通过构造器创建新的对象 向外提供一个公共静态方法用于获取自身的对象 代码实现: 饿汉式 1234567public class SingletonDemo&#123; private static SingletonDemo singleton = new SingletonDemo(); private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; return singleton; &#125;&#125; ​ 懒汉式(存在线程不安全) 12345678910public class SingletonDemo&#123; private static SingletonDemo singleton; private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; if(singleton == null)&#123; singleton = new SingletonDemo(); &#125; return singleton; &#125;&#125; 关于懒汉式单例模式线程安全的解决方案双重检查锁可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。 什么使双重检查加锁机制所谓双重加锁机制，指的是：并不是每一个进入getInstance方法都需要同步，而使先不同步，进入方法后先检查是否存在实例，如果不存在才进行下面的同步块，只是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。 双重检查锁加锁机制实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。 注意：在Java1.4及以前的版本中，很多jvm对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只能用Java5以上的版本。 提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但是并不建议大量采用。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://SarkerAllen.github.io/categories/设计模式/"}],"tags":[{"name":"singleton","slug":"singleton","permalink":"https://SarkerAllen.github.io/tags/singleton/"}]},{"title":"JavaWeb-Upload","slug":"JavaWeb-upload","date":"2019-07-14T14:07:27.000Z","updated":"2019-07-17T02:49:41.805Z","comments":true,"path":"2019/07/14/JavaWeb-upload/","link":"","permalink":"https://SarkerAllen.github.io/2019/07/14/JavaWeb-upload/","excerpt":"** JavaWeb中的upload** &lt;Excerpt in index | 首页摘要&gt; 一个人如果活着没有梦想,那和咸鱼有什么区别?","text":"** JavaWeb中的upload** &lt;Excerpt in index | 首页摘要&gt; 一个人如果活着没有梦想,那和咸鱼有什么区别? JavaWeb中upload &lt;The rest of contents | 余下全文&gt; JavaWeb中Upload问题解决使用multipart/form-data属性后无法获取参数解决方案 通过js代码解决 123456789101112131415&lt;form id=\"upload\" name=\"upload\" action=\"fileftp.jsp\" method=\"post\" ENCTYPE=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"otherName\" id=\"otherName\" value=\"abcdefg\"&gt; &lt;td nowrap&gt; &lt;input type=\"file\" id=\"file1\" name=\"file1\" value=\"\" size=\"40\" class=\"sbttn\"&gt; &lt;input type=\"submit\" value=\"upload\" class=\"sbttn\"&gt; &lt;/td&gt;&lt;/form&gt;&lt;script language=\"javascript\"&gt; function formSubmit()&#123; var action = \"fileftp.jsp\"; action += \"?otherName=\" + document.upload.otherName.value; document.upload.action = action; document.upload.submit(); &#125;&lt;/script&gt; 通过修改服务器端代码。利用jar包 commons-fileupload-1.2.2.jar和commons-io-1.4.jar 1234567891011121314151617//创建工厂//工厂类可以设置很多对上传文件的限制内容DiskFileItemFactory factory = new DiskFileItemFactory();//创建解析器ServletFileUpload sfu = new ServletFileUpload(factory);sfu.setSizeMax(intsize);//设置文件中的大小也可以设置单个文件的大小//解析requesttry&#123; List&lt;FileItem&gt; list = sfu.parseRequest(request); for(FileItem fileitem : list)&#123; if(fileitem.isFormField())&#123; //FileItem类型的对象里有一个方法isFormField(),可以判断表单项是表单域还是文件域 String name = fileitem.getFildName(); String value = fileitem.getString(); &#125; &#125;&#125; commons-fileUpload.jar 12public DiskFileItemFactory()public DiskFileItemFactory(int sizeThreshold, File repository) sizeThreshold:服务器内存，资源有限限制：sizeThreshold临界值，600KB 上传的文件，如果小于600KB，则把接受到的整个文件放在内存中，程序直接从内存中读取，如果文件大于600KB，则把传过来的文件分成很多部分放在磁盘上的某个零时文件夹，程序需要文件时就去内存和临时文件夹里的临时文件中去读取repository：配置临时文件夹的位置 1void setSizeThreshold(int sizeThreshold) Apache文件上传组件在解析上传数据中的每个字段内容时，需要临时保存解析出的数据，以便在后面进行数据的进一步处理(保存在磁盘特定位置或插入数据库)。 因为Java虚拟机默认可以使用的内存空间时有限的，超出限制时将会抛出“java.lang.OutOfMemoryError”错误。 如果上传的文件很大，例如800M的文件，在内存中将无法临时保存该文件内容，Apache文件上传组件转而采用临时文件来保存这些数据；但如果上传文件的问价很小，例如600个子节的文件，显然将其直接保存在内存中性能会更好一些sizeSizeThreshold方法用于设置是否将上传文件以临时问价的形式保存在磁盘的临界值(以子节为单位的int值)， 如果从没有调用该方法设置此临界值，将会采用系统的默认值10KB。对应的getSizeThreshold()方法来获取此临界值 1void setRepository(File repository) setRepositoryPath方法用于设置当上传文件尺寸大于setSizeThreshold方法设置的临界值时，将文件以临时文件形式保存在磁盘上的存放目录。有一个对应的获得临时文件夹的File getRespository()方法注意：当没有调用此方法设置临时文件存储目录时，默认采用系统默认的临时文件路径，可以通过系统属性java.io.tmpdir 获取。如下代码： 1System.getProperty(\"java.io.tmpdir\"); Tomcat服务器默认临时目录为“&lt;tomcat安装目录&gt;/temp/” FileItem类的常用方法： 1boolean isFormField() isFormField方法用于判断FileItem类对象封装的数据是一个普通文本表单字段，还是一个文件表单字段，如果是普通表单字段则放回true，否则返回false。因此，可以使用该方法判断是否为普通表单域，还是文件上传域。 1String getName() getName方法用于获得文件上传字段中的文件名。 注意 IE或FireFox中获取的文件名是不一样的，IE中式绝对路径，FireFox中只是文件名 1String getFieldName() getFieldName方法用于返回表单标签name属性的值。如上例中&lt;input type=”text” name=”column”&gt;的value 1void write(File file) write方法用于将FileItem对象中保存的主体内容保存到某个指定的文件中。如果FileItem对象中的主体内容是保存在某个临时文件中，该方法顺利完成后，临时文件有可能会被清楚。该方法也可将普通表单字段内容写如多一个文件中，但它主要用途是将上传的文件内容保存在本地文件系统中。 1String getString() getString方法用于将FileItem对象中保存的数据流内容以一个字符串返回，它有两个重载的定义形式： public java.lang.String getString() public java.lang.String getString(java.lang.String encoding) 前者使用缺省的字符集编码将主体内容转换成字符串，后者使用参数指定的字符集编码将主体内容转换成字符串。如果在读取普通表单字段元素的内容是出现了中文乱码现象，请调用第二个getString方法，并为之传递正确的字符集编码名称。 1String getContentType() getContentType方法用于获得上传文件的类型，即表单字段元素描述头属性“Content-Type”的值，如果“image/jpeg”。如果FileItem类对象对应的是普通表单字段，该方法将返回null。 1boolean isInMemory() isInMemoory方法用来判断FileItem对象封装的数据内容是存储在内存中，还是存储在临时文件中，如果存储在内存中则返回true，否则返回false 1void delete() delete方法用来清空FileItem类对象中存放的主体内容，如果主体内容被保存在临时文件中，delete方法将删除该临时文件 尽管当FileItem对象被垃圾收集器收集时会自动清楚临时文件，但及时调用delete方法可以更早的清除临时文件，释放系统存储资源。另外，当系统出现异常时，仍然可能造成有的临时文件被永久保存在了硬盘中。 1InputStream getInputStream() 以流的形式返回上传文件的数据内容 1long getSize() 返回该上传文件的大小（以子节为单位） 上传文件注意项： 为保证服务器安全，上传问价应该放在外界无法直接访问的目录下，比如放于WEB-INF目录下。 为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。 为防止一个目录下出现太多文件，要使用hash算法打散存储。 要限制上传文件的最大值 要限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。 基本思路 获取和创建保存文件的最终目录和临时目录 创建一个DiskFileItemFactory工厂 创建一个文件上传解析器 判断提交上来的数据是否是上传表单的数据，是不是Multipart编码方式ServletFileUpload.isMultipartContext(request) 使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List集合 判断普通域还是文件域 将普通表单域的键值对显示出来 验证后缀的合法性 将文件流写入保存的目录中(生成新的文件名，避免一个目录中文件太多而生成新的存储目录)","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode算法实现","slug":"LeetCode_961","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:43:57.416Z","comments":true,"path":"2019/05/13/LeetCode_961/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_961/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; LeetCode——961算法实现之C语言","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; LeetCode——961算法实现之C语言 &lt;The rest of contents | 余下全文&gt; LeetCode_961_N-Repeated Element in Size 2N Array题目描述在2n大小的数组a中，有n+1个唯一元素，其中一个元素重复n次。实现步骤方法一从数组的第三个元素开始，逐个与第1、2个元素比较，如果相等返回相等的值方法二1.定义三个变量，将数组的前三个元素分别赋给三个变量 2.判断数组的长度是否为4并且第一个元素与第四个元素相等 3.判断第一个元素与第二个或与第三个是否相等 4.判断第二个元素与第三个元素是否相等 5.将数组新元素重新赋给变量，重复3、4代码实现C语言1234567int repeatedNTimes(int* A, int ASize)&#123; for(int i = 2; i &lt; ASize; i++)&#123; if(A[i] == A[i - 1] || A[i] == A[i - 2]) return A[i]; &#125; return -1;&#125; Java语言12345678910111213141516171819public int repeatedNTimes(int[] A) &#123; int a = A[0]; int b = A[1]; int c = A[2]; int i = 3; if(A.length == 4 &amp;&amp; a == A[3]) return a; do&#123; if(a == b || a == c) return a; if(b == c) return b; a = b; b = c; c = A[i]; i++; &#125;while(i &lt;= A.length); return -1;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode——938算法","slug":"LeetCode_938","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:30:46.709Z","comments":true,"path":"2019/05/13/LeetCode_938/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_938/","excerpt":"** LeetCode题目解答** &lt;Excerpt in index | 首页摘要&gt; LeetCode——938题目C语言实现","text":"** LeetCode题目解答** &lt;Excerpt in index | 首页摘要&gt; LeetCode——938题目C语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_938_Range Sum of BST实现步骤1.遍历二叉树 2.如果val&lt;L,则遍历另一个节点 3.如果val&gt;R,则遍历另一个节点 4.如果val&gt;L&amp;&amp;val&lt;R,则sum+=val,然后遍历此节点的子节点代码实现（C语言）节点结构12345struct TreeNode&#123; int val; struct TreeNode* left; struct TreeNode* right;&#125;; 算法实现123456789101112131415161718int rangeSumBST(struct TreeNode* root, int L, int R)&#123; if(!root)&#123; return 0; &#125; int sum = 0; if(root-&gt;val &lt; L)&#123; sum += rangeSumBST(root-&gt;right, L, R); &#125; else if(root-&gt;val &gt; R)&#123; sum += rangeSumBST(root-&gt;left, L, R); &#125; else&#123; sum += root-&gt;val; sum += rangeSumBST(root-&gt;left, L, R); sum += rangeSumBST(root-&gt;right, L, R); &#125; return sum;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode算法实现——709","slug":"LeetCode_709","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:43:23.521Z","comments":true,"path":"2019/05/13/LeetCode_709/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_709/","excerpt":"** LeetCode——709** &lt;Excerpt in index | 首页摘要&gt; LeetCode——709算法C语言与Java语言实现","text":"** LeetCode——709** &lt;Excerpt in index | 首页摘要&gt; LeetCode——709算法C语言与Java语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_709_To Lower Case实现步骤1.获取传入参数(字符数组) 2.将字符串拆分为字符数组 3.判断字母是否为大写 4.根据大小写之间ASCII值的关系进行转换 5.返回改变后的字符代码实现C语言12345678910char * toLowerCase(char * str)&#123; char *p = str; while(*p != '\\0')&#123; if(*p &gt;= 'A' &amp;&amp; *p &lt;= 'Z')&#123; *P += 32; &#125; *p++; &#125; return str;&#125; Java12345public class Solution&#123; public String toLowerCase(String str)&#123; return str.toLowerCase(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode_804_题目解答","slug":"LeetCode_804","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:27:43.859Z","comments":true,"path":"2019/05/13/LeetCode_804/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_804/","excerpt":"** LeetCode——804** &lt;Excerpt in index | 首页摘要&gt; LeetCode——804——题目分析与C语言实现","text":"** LeetCode——804** &lt;Excerpt in index | 首页摘要&gt; LeetCode——804——题目分析与C语言实现 &lt;The rest of contents | 余下全文&gt; LeetCode_804_Unique Morse Code Words实现步骤1.建立Morse对照数组 2.声明一个数组用于存放一个字符串的Morse对应编码 3.声明一个数组用于存放重复的Morse码 4.将字符串逐个转化为Morse码 5.将字符串的Morse码与数组中的每一个Morse码对比，如果相同则退出比较，如果该Morse码不存在与数组中，则将该Morse码添加至该数组代码实现(C语言)123456789101112131415161718192021222324252627int uniqueMorseRepresentations(char ** words, int wordsSize)&#123; char morse[][5]=&#123;\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\", \"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"&#125;; int i, j, k, find, count = 0; char string[100]; char unique[100][100] = &#123;\"\"&#125;; for(i = 0; i &lt; wordsSize; i++)&#123; j = 0; strcpy(string, \"\"); while(words[i][j])&#123; strcat(string, morse[words[i][j++] - 'a']); &#125; find = 0; for(k = 0; k &lt; count; k++)&#123; if(strcmp(string, unique[k]) == 0)&#123; find = 1; &#125; &#125; if(!find)&#123; strcpy(unique[count++], string); &#125; &#125; return count;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"java和javascript日期详解","slug":"java-date","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:02:39.261Z","comments":true,"path":"2019/05/13/java-date/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/java-date/","excerpt":"** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt; java的各种日期转换","text":"** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt; java的各种日期转换 &lt;The rest of contents | 余下全文&gt; 日期表示类型 获取long类型的日期格式 1234long time = System.currentTimeMillis();System.out.printf(time+\"\");Date date =new Date();System.out.println(date.getTime()); 获取制定格式的日期 123SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");Date date =new Date();System.out.println(sdf.format(date) ); 把制定格式的日期转为date或者毫秒值 123SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");Date date = sdf.parse(\"2016-05-22 10:15:21\");long mills = date.getTime(); 说明:System.currentTimeMillis()并不能精确到1ms的级别,它取决于运行的系统,你再windows,mac,linux精确的范围都有差异,对于有高精度时间的要求,不能使用这个 日期计算 最方便的方式是将时间转为毫秒值进行计算1234Date from =new Date();Thread.sleep(200);//线程休眠2msDate to =new Date();System.out.println(to.getTime()-from.getTime()); 高精度时间12long time1 =System.nanoTime();System.out.printf(time1+\"\"); 说明:System.nanoTime()提高了ns级别的精度,1ms=1000000ns, javascript日期 获取时间的毫秒值，获取月份，时间 1234567891011121314var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间 时间戳获取注意，java，php等生成的时间戳是秒，不是毫秒，所以需要签名时间戳的时候，需要转为秒时间戳 12var time = new Date();var timestamp = parseInt(time.getTime()/1000); 格式化时间 12345678910111213141516//获取当前时间，格式YYYY-MM-DDfunction getNowFormatDate() &#123; var date = new Date(); var seperator1 = \"-\"; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = \"0\" + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = \"0\" + strDate; &#125; var currentdate = year + seperator1 + month + seperator1 + strDate; return currentdate;&#125;","categories":[{"name":"language","slug":"language","permalink":"https://SarkerAllen.github.io/categories/language/"}],"tags":[{"name":"java","slug":"java","permalink":"https://SarkerAllen.github.io/tags/java/"}]},{"title":"LeetCode算法实现","slug":"LeetCode_1021","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:33:55.982Z","comments":true,"path":"2019/05/13/LeetCode_1021/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_1021/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——1021","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——1021 &lt;The rest of contents | 余下全文&gt; LeetCode_1021_Remove Outermost Parentheses实现步骤1.计算字符串的长度，如果长度等于0或长度不是偶数返回&quot;&quot; 2.判断字符串开头是否为&apos;(&apos;，如果不是返回&quot;&quot; 3.创建一个变量A(result)，用于返回计算结果 4.循环遍历字符串，如果是&apos;(&apos;,count++,否则count-- 5.如果count大于等于2时将字符可写入改为true，如果count等于0时将字符可写入改为false 6.将可写入位置的字符赋值给变量A(result) 7.将变量A(result)末尾位置赋值为&apos;\\0&apos;代码实现C语言123456789101112131415161718192021222324252627282930313233343536char * removeOuterParentheses(char * S)&#123; int len = strlen(S); if(len == 0)&#123; return \"\"; &#125; if(len % 2)&#123; return \"\"; &#125; if(S[i] != '(')&#123; return \"\"; &#125; char * result = (char *)malloc(len); int flag = 0; int count = 0; int j = 0 for(int i = 0; i &lt; len; i++)&#123; if(S[i] == '(')&#123; count++; &#125; else if(S[i] == ')')&#123; count--; &#125; if(count == 0)&#123; flag = 0; &#125; else if(count &gt;= 2)&#123; flag = 1; &#125; if(flag)&#123; result[j] = S[i]; j++; &#125; &#125; result[j] = '\\0'; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"LeetCode——题目905","slug":"LeetCode_905","date":"2019-05-13T13:48:00.000Z","updated":"2019-07-16T10:29:10.293Z","comments":true,"path":"2019/05/13/LeetCode_905/","link":"","permalink":"https://SarkerAllen.github.io/2019/05/13/LeetCode_905/","excerpt":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——905算法","text":"** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt; C语言实现LeetCode——905算法 &lt;The rest of contents | 余下全文&gt; LeetCode_905_Sort Array By Parity实现步骤1.双向遍历数组 2.如果头指针指向的数字时奇数，尾指针指向的数字是偶数则交换两数位置 3.如果头指针指向的数字是偶数，尾指针指向的数字是奇数或者头指针和尾指针指向的数字都是奇数则不交换数字，尾指针向前移动一位 4.如果不符合2、3则头指针向后移动一位 5.返回修改后的数组代码实现(C语言)1234567891011121314151617181920int* sortArrayByParity(int* A, int ASize, int* resultSize)&#123; int *head = A; int *foot = A + (ASize - 1); int *temp = (int *)malloc(sizeof(int)); while(head &gt; foot)&#123; if(*head % 2 == 1 &amp;&amp; *foot % 2 == 0)&#123; *temp = *head; *head = *foot; *foot = *temp; head++; foot--; &#125; else if((*head % 2 == 0 &amp;&amp; *head % 2 == 1) || (*head % 2 == 1 &amp;&amp; *foot % 2 == 1)) foot--; else head++; &#125; *resultSize = ASize; return A;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://SarkerAllen.github.io/categories/algorithm/"}],"tags":[{"name":"C","slug":"C","permalink":"https://SarkerAllen.github.io/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-31T16:00:00.000Z","updated":"2019-07-18T15:59:36.231Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"https://SarkerAllen.github.io/2019/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin&#39;s Blog</title>
  
  <subtitle>Kevin的技术分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://SarkerAllen.github.io/"/>
  <updated>2019-07-20T07:53:05.847Z</updated>
  <id>https://SarkerAllen.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的泛型</title>
    <link href="https://SarkerAllen.github.io/2019/07/20/java-generic/"/>
    <id>https://SarkerAllen.github.io/2019/07/20/java-generic/</id>
    <published>2019-07-20T06:07:08.000Z</published>
    <updated>2019-07-20T07:53:05.847Z</updated>
    
    <content type="html"><![CDATA[<p>*<em>浅谈Java中的泛型 *</em> &lt;Excerpt in index | 首页摘要&gt;<br>    Java中的泛型、泛型类、泛型方法</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h3><ul><li>存储在集合中的元素，取出来都是Object类型的，此时就得强转</li><li>约束存储到集合中的元素必须是相同的数据类型</li><li>设计一个点类，来封装坐标位置，要求坐标位置支持String支持integer支持double类型（重复设计）</li></ul><h3 id="泛型-Generic-Type"><a href="#泛型-Generic-Type" class="headerlink" title="泛型(Generic Type)"></a>泛型(Generic Type)</h3><p>从Java5开始支持的新语法</p><h4 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h4><ul><li>广泛通用的类型</li><li>代码模板中类型不确定，谁调用该段代码，谁指明类型</li></ul><p>简单定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">private</span> T y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">public</span> T getY&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(T y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型尖括号中可以使用T:Type E：Element K:Key V:Value</span></span><br><span class="line"><span class="comment">//具体是什么类型取决于调用者，不对泛型进行设置默认object</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Point&lt;String&gt; p1 = <span class="keyword">new</span> Point&lt;String&gt;();</span><br><span class="line">        Point&lt;Integer&gt; p2 = <span class="keyword">new</span> Point&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>直接在类/接口上定义的类型</p><p>泛型类的子类继承泛型类是需要指定类型</p><p>使用泛型：保证前后类型一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//该list只能存储String类型的元素</span></span><br></pre></td></tr></table></figure><p>因为前后类型相同，所以Java7开始，推出了泛型的菱形语法&lt;&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>泛型不存在继承的关系，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt;list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><p>从此以后，使用集合都得使用泛型来约束该集合中的元素的类型</p><p>通过反编译发现：泛型也是语法糖，底层依然使用强制类型转换的方式实现</p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>在方法上声明泛型</p><ul><li>泛型类中的泛型只能适用于非静态方法，如果需要给静态方法设置泛型，此时使用泛型方法</li><li>泛型类中的泛型应该适用于整个类中的多个方法，有时候支队某一个方法设置泛型即可</li></ul><p>一般的，把自定义的泛型作为该方法的返回类型才有意义，而且此时的泛型必须是由参数设置进来的，如果没有参数来设置泛型的具体类型，此时的方法一般返回设计为Object即可</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示在该方法中使用T来表示一种未知类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">Demo</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型的通配符、上限和下限"><a href="#泛型的通配符、上限和下限" class="headerlink" title="泛型的通配符、上限和下限"></a>泛型的通配符、上限和下限</h3><ul><li><p>泛型的通配符：不知道用什么类型来接收时，此时可以使用？，？表示未知通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(List&lt;?&gt;list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//此时只能接收数据，不能添加数据至list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型的上限和下限：用来限定元素的类型必须时X类的子类或相同，X类的父类或相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型的上限：此时的泛型？必须时Numer类型或Number类的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(List&lt;? extends Number&gt; list)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的下限：此时的泛型？必须时Number类型或Number类的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt;list)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型的擦除和转换"><a href="#泛型的擦除和转换" class="headerlink" title="泛型的擦除和转换"></a>泛型的擦除和转换</h3><ul><li><p>泛型的擦除：</p><ol><li><p>泛型编译之后就消失了(泛型的自动擦除)</p></li><li><p>当把带有泛型的集合赋给不带泛型的集合，此时泛型被擦除(手动擦除)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        List list2 = <span class="keyword">null</span>;</span><br><span class="line">        list2 = list1;<span class="comment">//此时泛型擦除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>堆污染：</p><p>当一个方法既使用泛型的时候也使用可变参数，此时容易导致堆污染问题。</p><p>如：在Arrays类中的 <strong>asList()</strong> 方法</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;*&lt;em&gt;浅谈Java中的泛型 *&lt;/em&gt; &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    Java中的泛型、泛型类、泛型方法&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://SarkerAllen.github.io/categories/language/"/>
    
    
      <category term="java" scheme="https://SarkerAllen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java中的List、Set与Map集合</title>
    <link href="https://SarkerAllen.github.io/2019/07/19/Java-List-Set-Map/"/>
    <id>https://SarkerAllen.github.io/2019/07/19/Java-List-Set-Map/</id>
    <published>2019-07-19T15:30:23.000Z</published>
    <updated>2019-07-20T03:49:30.748Z</updated>
    
    <content type="html"><![CDATA[<p>*<em>浅谈Java中的List、Set与Map集合 *</em> &lt;Excerpt in index | 首页摘要&gt;<br>    Java中的List、Set与Map集合分析</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="接口继承关系以及实现"><a href="#接口继承关系以及实现" class="headerlink" title="接口继承关系以及实现"></a>接口继承关系以及实现</h2><p>集合类存放于Java.util包中，主要有3种：List、Set和Map。</p><ul><li><p>Collection：Collection是集合List、Set、Queue的最基本的接口</p></li><li><p>Iterator：迭代器，可以通过迭代器遍历集合中的数据</p></li><li><p>Map：是映射表的基础接口</p></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Java的List是非常用的数据类型。List是有序的Collection。Java List一共三个类：分别是ArrayList、Vector和LinkedList。</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足是需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，它还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set注重独一无二的性质，该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象的hashCode值(Java是依据对象的内存地址计算出的次序号)判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object和hashCode方法的equals方法。Java Set一共三个实现类：分别是HashSet、TreeSet和LinkHashSet。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>哈希表里边存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序(与List显然不同)而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashCode方法来获取的，HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法，如果equals结果尾true，HashSet就视为同一个元素。如果equals为false就不是同一个元素。</p><p>哈希值相同equals为false的元素是怎么存储呢，就是在同样的哈希值下顺延(可以认为哈希值相同的元素放在一个哈希桶中)。也就是哈希一样的存一列。HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置可以存放多个元素。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul><li>TreeSet()是使用二叉树的原理对add()的对象按照指定的顺序排序(升序、降序)，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置</li><li>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自定义的类必须实现Comparable接口，并且覆写相应的compareTo()方法，才可以正常使用。</li><li>在覆写compareTo()方法时，要返回相应的值才能使TreeSet按照一定的规则来排序。</li><li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li></ul><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>对于LinkedHashSet而言，它继承于HashSet、又基于LinkedHashMap来实现的。</p><p>LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法是HashMap具有线程安全的能里，或者使用ConcurrentHashMap。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>HashTable是遗留类，很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写HashTable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。HashTable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是有序的。如果使用排序的映射，建议使用TreeMap。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录时先插入的，也可以在构造时带参数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h3><ul><li>List有序、可以重复，有三个实现类，ArrayList、LinkedList、Vector</li><li>Set无序、不可重复，有两个实现类，HashSet、LinkedHashSet</li><li>Map键不可以重复、值可以重复，有三个实现类，HashMap、HashTable、LinkedHashMap</li></ul><h3 id="List三个子类的区别"><a href="#List三个子类的区别" class="headerlink" title="List三个子类的区别"></a>List三个子类的区别</h3><ul><li>ArrayList：底层使用Object[]数组实现，内存地址都是连续的便于索引，查询快；在新增的时候需要申请一块连续的内存空间，所以增删比较慢。</li><li>LinkedList：底层是基于链表实现，链表内存是散乱的，在存储自身内存地址的同时，还存储着下一个元素的内存地址，所以查询慢，增删快。</li><li>Vector：底层数组实现，由于所有的方法都是采用synchronize，线程安全，效率慢。</li></ul><h3 id="Map三个子类的区别"><a href="#Map三个子类的区别" class="headerlink" title="Map三个子类的区别"></a>Map三个子类的区别</h3><ul><li>HashMap：基于hash表的Map接口实现，非线程安全，支持键null，值null</li><li>HashTable：线程安全，不支持键null，值null</li><li>LinkedHashMap：持两种排序，插入顺序和访问顺序。前者是指按照插入时的顺序排序，后者是指按照最旧使用到最近使用的顺序</li></ul><h3 id="Set两个子类的区别"><a href="#Set两个子类的区别" class="headerlink" title="Set两个子类的区别"></a>Set两个子类的区别</h3><ul><li>HashSet：底层由HashMap实现</li><li>LinkedHashSet：LinkedHashSet继承自HashSet，源码更少、更简单，唯一的区别时LinkedHashSet内部使用的时LinkHashMap。这样做的意义或者好处时LinkedHashSet中的元素顺序是可以保证的，也就是说遍历顺序和插入顺序是一致的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;*&lt;em&gt;浅谈Java中的List、Set与Map集合 *&lt;/em&gt; &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    Java中的List、Set与Map集合分析&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://SarkerAllen.github.io/categories/language/"/>
    
    
      <category term="java" scheme="https://SarkerAllen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——单例模式(浅谈)</title>
    <link href="https://SarkerAllen.github.io/2019/07/18/Singleton/"/>
    <id>https://SarkerAllen.github.io/2019/07/18/Singleton/</id>
    <published>2019-07-18T15:15:14.000Z</published>
    <updated>2019-07-18T16:00:37.452Z</updated>
    
    <content type="html"><![CDATA[<p><strong>浅谈单例设计模式:</strong>  &lt;Excerpt in index | 首页摘要&gt;<br>    单例设计模式以及java语言简单实现</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="单例设计模式-浅谈"><a href="#单例设计模式-浅谈" class="headerlink" title="单例设计模式(浅谈)"></a>单例设计模式(浅谈)</h2><h3 id="什么是设计模式-Design-Pattern"><a href="#什么是设计模式-Design-Pattern" class="headerlink" title="什么是设计模式 (Design Pattern)"></a>什么是设计模式 (Design Pattern)</h3><p>设计模式是一套被人反复使用、多数人知晓、经过分类的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络。</p><h3 id="单例模式-Singleton-最常用的、最简单的设计模式"><a href="#单例模式-Singleton-最常用的、最简单的设计模式" class="headerlink" title="单例模式 (Singleton) 最常用的、最简单的设计模式"></a>单例模式 (Singleton) 最常用的、最简单的设计模式</h3><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。<br>保证在整个应用中某一个类有且只有一个实例(一个类在内存中只存在一个对象)，即所有的指向该类型实例的引用都指向同一块内存空间。</p><h3 id="单例设计模式实现的步骤"><a href="#单例设计模式实现的步骤" class="headerlink" title="单例设计模式实现的步骤:"></a>单例设计模式实现的步骤:</h3><ol><li><p>必须在类中自己先创建一个对象</p></li><li><p>私用自身的构造器，防止外界通过构造器创建新的对象</p></li><li><p>向外提供一个公共静态方法用于获取自身的对象</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><p>   饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo singleton = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        懒汉式(存在线程不安全)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于懒汉式单例模式线程安全的解决方案"><a href="#关于懒汉式单例模式线程安全的解决方案" class="headerlink" title="关于懒汉式单例模式线程安全的解决方案"></a>关于懒汉式单例模式线程安全的解决方案</h2><h3 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h3><p>可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。</p><h3 id="什么使双重检查加锁机制"><a href="#什么使双重检查加锁机制" class="headerlink" title="什么使双重检查加锁机制"></a>什么使双重检查加锁机制</h3><p>所谓双重加锁机制，指的是：并不是每一个进入getInstance方法都需要同步，而使先不同步，进入方法后先检查是否存在实例，如果不存在才进行下面的同步块，只是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p><p>双重检查锁加锁机制实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p><p><strong>注意：</strong>在Java1.4及以前的版本中，很多jvm对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只能用Java5以上的版本。</p><p><strong>提示：</strong>由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但是并不建议大量采用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;浅谈单例设计模式:&lt;/strong&gt;  &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    单例设计模式以及java语言简单实现&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://SarkerAllen.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="singleton" scheme="https://SarkerAllen.github.io/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb-Upload</title>
    <link href="https://SarkerAllen.github.io/2019/07/14/JavaWeb-upload/"/>
    <id>https://SarkerAllen.github.io/2019/07/14/JavaWeb-upload/</id>
    <published>2019-07-14T14:07:27.000Z</published>
    <updated>2019-07-17T02:49:41.805Z</updated>
    
    <content type="html"><![CDATA[<p>** JavaWeb中的upload** &lt;Excerpt in index | 首页摘要&gt;<br>    一个人如果活着没有梦想,那和咸鱼有什么区别?</p><a id="more"></a>JavaWeb中upload<p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="JavaWeb中Upload问题解决"><a href="#JavaWeb中Upload问题解决" class="headerlink" title="JavaWeb中Upload问题解决"></a>JavaWeb中Upload问题解决</h2><h2 id="使用multipart-form-data属性后无法获取参数"><a href="#使用multipart-form-data属性后无法获取参数" class="headerlink" title="使用multipart/form-data属性后无法获取参数"></a>使用multipart/form-data属性后无法获取参数</h2><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>通过js代码解决</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">name</span>=<span class="string">"upload"</span> <span class="attr">action</span>=<span class="string">"fileftp.jsp"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">ENCTYPE</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"otherName"</span> <span class="attr">id</span>=<span class="string">"otherName"</span> <span class="attr">value</span>=<span class="string">"abcdefg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">nowrap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file1"</span> <span class="attr">name</span>=<span class="string">"file1"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">size</span>=<span class="string">"40"</span> <span class="attr">class</span>=<span class="string">"sbttn"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span> <span class="attr">class</span>=<span class="string">"sbttn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span></span><br><span class="line">    function formSubmit()&#123;</span><br><span class="line">        var action = "fileftp.jsp";</span><br><span class="line">        action += "?otherName=" + document.upload.otherName.value;</span><br><span class="line">        document.upload.action = action;</span><br><span class="line">        document.upload.submit();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>通过修改服务器端代码。利用jar包</p><p>commons-fileupload-1.2.2.jar和commons-io-1.4.jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂</span></span><br><span class="line"><span class="comment">//工厂类可以设置很多对上传文件的限制内容</span></span><br><span class="line">DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line"><span class="comment">//创建解析器</span></span><br><span class="line">ServletFileUpload sfu = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">sfu.setSizeMax(intsize);<span class="comment">//设置文件中的大小也可以设置单个文件的大小</span></span><br><span class="line"><span class="comment">//解析request</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    List&lt;FileItem&gt; list = sfu.parseRequest(request);</span><br><span class="line">    <span class="keyword">for</span>(FileItem fileitem : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fileitem.isFormField())&#123;</span><br><span class="line">            <span class="comment">//FileItem类型的对象里有一个方法isFormField(),可以判断表单项是表单域还是文件域</span></span><br><span class="line">            String name = fileitem.getFildName();</span><br><span class="line">            String value = fileitem.getString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>commons-fileUpload.jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskFileItemFactory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskFileItemFactory</span><span class="params">(<span class="keyword">int</span> sizeThreshold, File repository)</span></span></span><br></pre></td></tr></table></figure><p>sizeThreshold:服务器内存，资源有限<br>限制：sizeThreshold临界值，600KB 上传的文件，如果小于600KB，则把接受到的整个文件放在内存中，程序直接从内存中读取，如果文件大于600KB，则把传过来的文件分成很多部分放在磁盘上的某个零时文件夹，程序需要文件时就去内存和临时文件夹里的临时文件中去读取<br>repository：配置临时文件夹的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSizeThreshold</span><span class="params">(<span class="keyword">int</span> sizeThreshold)</span></span></span><br></pre></td></tr></table></figure><p>Apache文件上传组件在解析上传数据中的每个字段内容时，需要临时保存解析出的数据，以便在后面进行数据的进一步处理(保存在磁盘特定位置或插入数据库)。</p><p>因为Java虚拟机默认可以使用的内存空间时有限的，超出限制时将会抛出“java.lang.OutOfMemoryError”错误。</p><p>如果上传的文件很大，例如800M的文件，在内存中将无法临时保存该文件内容，Apache文件上传组件转而采用临时文件来保存这些数据；但如果上传文件的问价很小，例如600个子节的文件，显然将其直接保存在内存中性能会更好一些<br>sizeSizeThreshold方法用于设置是否将上传文件以临时问价的形式保存在磁盘的临界值(以子节为单位的int值)，</p><p>如果从没有调用该方法设置此临界值，将会采用系统的默认值10KB。对应的getSizeThreshold()方法来获取此临界值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRepository</span><span class="params">(File repository)</span></span></span><br></pre></td></tr></table></figure><p>setRepositoryPath方法用于设置当上传文件尺寸大于setSizeThreshold方法设置的临界值时，将文件以临时文件形式保存在磁盘上的存放目录。有一个对应的获得临时文件夹的File getRespository()方法<br><strong>注意</strong>：当没有调用此方法设置临时文件存储目录时，默认采用系统默认的临时文件路径，可以通过系统属性java.io.tmpdir 获取。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(<span class="string">"java.io.tmpdir"</span>);</span><br></pre></td></tr></table></figure><p>Tomcat服务器默认临时目录为“&lt;tomcat安装目录&gt;/temp/”</p></li><li><p>FileItem类的常用方法：</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFormField</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>isFormField方法用于判断FileItem类对象封装的数据是一个普通文本表单字段，还是一个文件表单字段，如果是普通表单字段则放回true，否则返回false。因此，可以使用该方法判断是否为普通表单域，还是文件上传域。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>getName方法用于获得文件上传字段中的文件名。</p><p><strong>注意</strong> IE或FireFox中获取的文件名是不一样的，IE中式绝对路径，FireFox中只是文件名</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFieldName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>getFieldName方法用于返回表单标签name属性的值。如上例中&lt;input type=”text” name=”column”&gt;的value</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(File file)</span></span></span><br></pre></td></tr></table></figure><p>write方法用于将FileItem对象中保存的主体内容保存到某个指定的文件中。如果FileItem对象中的主体内容是保存在某个临时文件中，该方法顺利完成后，临时文件有可能会被清楚。该方法也可将普通表单字段内容写如多一个文件中，但它主要用途是将上传的文件内容保存在本地文件系统中。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>getString方法用于将FileItem对象中保存的数据流内容以一个字符串返回，它有两个重载的定义形式：</p><p>public java.lang.String getString()</p><p>public java.lang.String getString(java.lang.String encoding)</p><p>前者使用缺省的字符集编码将主体内容转换成字符串，后者使用参数指定的字符集编码将主体内容转换成字符串。如果在读取普通表单字段元素的内容是出现了中文乱码现象，请调用第二个getString方法，并为之传递正确的字符集编码名称。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getContentType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>getContentType方法用于获得上传文件的类型，即表单字段元素描述头属性“Content-Type”的值，如果“image/jpeg”。如果FileItem类对象对应的是普通表单字段，该方法将返回null。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInMemory</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>isInMemoory方法用来判断FileItem对象封装的数据内容是存储在内存中，还是存储在临时文件中，如果存储在内存中则返回true，否则返回false</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>delete方法用来清空FileItem类对象中存放的主体内容，如果主体内容被保存在临时文件中，delete方法将删除该临时文件</p><p>尽管当FileItem对象被垃圾收集器收集时会自动清楚临时文件，但及时调用delete方法可以更早的清除临时文件，释放系统存储资源。另外，当系统出现异常时，仍然可能造成有的临时文件被永久保存在了硬盘中。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>以流的形式返回上传文件的数据内容</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getSize</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回该上传文件的大小（以子节为单位）</p></li></ul></li><li><p>上传文件注意项：</p><ul><li>为保证服务器安全，上传问价应该放在外界无法直接访问的目录下，比如放于WEB-INF目录下。</li><li>为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。</li><li>为防止一个目录下出现太多文件，要使用hash算法打散存储。</li><li>要限制上传文件的最大值</li><li>要限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。</li></ul></li><li><p>基本思路</p><ol><li>获取和创建保存文件的最终目录和临时目录</li><li>创建一个DiskFileItemFactory工厂</li><li>创建一个文件上传解析器</li><li>判断提交上来的数据是否是上传表单的数据，是不是Multipart编码方式ServletFileUpload.isMultipartContext(request)</li><li>使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List<fileitem>集合</fileitem></li><li>判断普通域还是文件域</li><li>将普通表单域的键值对显示出来</li><li>验证后缀的合法性</li><li>将文件流写入保存的目录中(生成新的文件名，避免一个目录中文件太多而生成新的存储目录)</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** JavaWeb中的upload** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    一个人如果活着没有梦想,那和咸鱼有什么区别?&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://SarkerAllen.github.io/categories/language/"/>
    
    
      <category term="java" scheme="https://SarkerAllen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——题目905</title>
    <link href="https://SarkerAllen.github.io/2019/05/13/LeetCode_905/"/>
    <id>https://SarkerAllen.github.io/2019/05/13/LeetCode_905/</id>
    <published>2019-05-13T13:48:00.000Z</published>
    <updated>2019-07-16T10:29:10.293Z</updated>
    
    <content type="html"><![CDATA[<p>** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt;<br>    C语言实现LeetCode——905算法</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="LeetCode-905-Sort-Array-By-Parity"><a href="#LeetCode-905-Sort-Array-By-Parity" class="headerlink" title="LeetCode_905_Sort Array By Parity"></a>LeetCode_905_Sort Array By Parity</h2><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><pre><code>1.双向遍历数组2.如果头指针指向的数字时奇数，尾指针指向的数字是偶数则交换两数位置3.如果头指针指向的数字是偶数，尾指针指向的数字是奇数或者头指针和尾指针指向的数字都是奇数则不交换数字，尾指针向前移动一位4.如果不符合2、3则头指针向后移动一位5.返回修改后的数组</code></pre><h2 id="代码实现-C语言"><a href="#代码实现-C语言" class="headerlink" title="代码实现(C语言)"></a>代码实现(C语言)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">sortArrayByParity</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> ASize, <span class="keyword">int</span>* resultSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *head = A;</span><br><span class="line">    <span class="keyword">int</span> *foot = A + (ASize - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(head &gt; foot)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*head % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; *foot % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            *temp = *head;</span><br><span class="line">            *head = *foot;</span><br><span class="line">            *foot = *temp;</span><br><span class="line">            head++;</span><br><span class="line">            foot--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*head % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; *head % <span class="number">2</span> == <span class="number">1</span>) || (*head % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; *foot % <span class="number">2</span> == <span class="number">1</span>))</span><br><span class="line">            foot--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            head++;</span><br><span class="line">    &#125;</span><br><span class="line">    *resultSize = ASize;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** LeetCode算法实现** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    C语言实现LeetCode——905算法&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://SarkerAllen.github.io/categories/algorithm/"/>
    
    
      <category term="C" scheme="https://SarkerAllen.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode算法实现</title>
    <link href="https://SarkerAllen.github.io/2019/05/13/LeetCode_1021/"/>
    <id>https://SarkerAllen.github.io/2019/05/13/LeetCode_1021/</id>
    <published>2019-05-13T13:48:00.000Z</published>
    <updated>2019-07-16T10:33:55.982Z</updated>
    
    <content type="html"><![CDATA[<p>** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt;<br>    C语言实现LeetCode——1021</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="LeetCode-1021-Remove-Outermost-Parentheses"><a href="#LeetCode-1021-Remove-Outermost-Parentheses" class="headerlink" title="LeetCode_1021_Remove Outermost Parentheses"></a>LeetCode_1021_Remove Outermost Parentheses</h2><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><pre><code>1.计算字符串的长度，如果长度等于0或长度不是偶数返回&quot;&quot;2.判断字符串开头是否为&apos;(&apos;，如果不是返回&quot;&quot;3.创建一个变量A(result)，用于返回计算结果4.循环遍历字符串，如果是&apos;(&apos;,count++,否则count--5.如果count大于等于2时将字符可写入改为true，如果count等于0时将字符可写入改为false6.将可写入位置的字符赋值给变量A(result)7.将变量A(result)末尾位置赋值为&apos;\0&apos;</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">removeOuterParentheses</span><span class="params">(<span class="keyword">char</span> * S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len % <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S[i] != <span class="string">'('</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> * result = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            result[j] = S[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result[j] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** LeetCode算法实现** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    C语言实现LeetCode——1021&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://SarkerAllen.github.io/categories/algorithm/"/>
    
    
      <category term="C" scheme="https://SarkerAllen.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode算法实现——709</title>
    <link href="https://SarkerAllen.github.io/2019/05/13/LeetCode_709/"/>
    <id>https://SarkerAllen.github.io/2019/05/13/LeetCode_709/</id>
    <published>2019-05-13T13:48:00.000Z</published>
    <updated>2019-07-16T10:43:23.521Z</updated>
    
    <content type="html"><![CDATA[<p>** LeetCode——709** &lt;Excerpt in index | 首页摘要&gt;<br>    LeetCode——709算法C语言与Java语言实现</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="LeetCode-709-To-Lower-Case"><a href="#LeetCode-709-To-Lower-Case" class="headerlink" title="LeetCode_709_To Lower Case"></a>LeetCode_709_To Lower Case</h2><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><pre><code>1.获取传入参数(字符数组)2.将字符串拆分为字符数组3.判断字母是否为大写4.根据大小写之间ASCII值的关系进行转换5.返回改变后的字符</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">toLowerCase</span><span class="params">(<span class="keyword">char</span> * str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = str;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*p &gt;= <span class="string">'A'</span> &amp;&amp; *p &lt;= <span class="string">'Z'</span>)&#123;</span><br><span class="line">            *P += <span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** LeetCode——709** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    LeetCode——709算法C语言与Java语言实现&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://SarkerAllen.github.io/categories/algorithm/"/>
    
    
      <category term="java" scheme="https://SarkerAllen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode算法实现</title>
    <link href="https://SarkerAllen.github.io/2019/05/13/LeetCode_961/"/>
    <id>https://SarkerAllen.github.io/2019/05/13/LeetCode_961/</id>
    <published>2019-05-13T13:48:00.000Z</published>
    <updated>2019-07-16T10:43:57.416Z</updated>
    
    <content type="html"><![CDATA[<p>** LeetCode算法实现** &lt;Excerpt in index | 首页摘要&gt;<br>    LeetCode——961算法实现之C语言</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="LeetCode-961-N-Repeated-Element-in-Size-2N-Array"><a href="#LeetCode-961-N-Repeated-Element-in-Size-2N-Array" class="headerlink" title="LeetCode_961_N-Repeated Element in Size 2N Array"></a>LeetCode_961_N-Repeated Element in Size 2N Array</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>在2n大小的数组a中，有n+1个唯一元素，其中一个元素重复n次。</code></pre><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code>从数组的第三个元素开始，逐个与第1、2个元素比较，如果相等返回相等的值</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code>1.定义三个变量，将数组的前三个元素分别赋给三个变量2.判断数组的长度是否为4并且第一个元素与第四个元素相等3.判断第一个元素与第二个或与第三个是否相等4.判断第二个元素与第三个元素是否相等5.将数组新元素重新赋给变量，重复3、4</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> ASize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; ASize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == A[i - <span class="number">1</span>] || A[i] == A[i - <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">return</span> A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> b = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> c = A[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(A.length == <span class="number">4</span> &amp;&amp; a == A[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b || a == c)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span>(b == c)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = A[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i &lt;= A.length);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** LeetCode算法实现** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    LeetCode——961算法实现之C语言&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://SarkerAllen.github.io/categories/algorithm/"/>
    
    
      <category term="java" scheme="https://SarkerAllen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java和javascript日期详解</title>
    <link href="https://SarkerAllen.github.io/2019/05/13/java-date/"/>
    <id>https://SarkerAllen.github.io/2019/05/13/java-date/</id>
    <published>2019-05-13T13:48:00.000Z</published>
    <updated>2019-07-16T10:02:39.261Z</updated>
    
    <content type="html"><![CDATA[<p>** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt;<br>    java的各种日期转换</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="日期表示类型"><a href="#日期表示类型" class="headerlink" title="日期表示类型"></a>日期表示类型</h2><ol><li><p>获取long类型的日期格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">System.out.printf(time+<span class="string">""</span>);</span><br><span class="line">Date date =<span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date.getTime());</span><br></pre></td></tr></table></figure></li><li><p>获取制定格式的日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">Date date =<span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(sdf.format(date) );</span><br></pre></td></tr></table></figure></li><li><p>把制定格式的日期转为date或者毫秒值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">Date date = sdf.parse(<span class="string">"2016-05-22 10:15:21"</span>);</span><br><span class="line"><span class="keyword">long</span> mills = date.getTime();</span><br></pre></td></tr></table></figure></li></ol><ul><li>说明:System.currentTimeMillis()并不能精确到1ms的级别,它取决于运行的系统,你再windows,mac,linux精确的范围都有差异,对于有高精度时间的要求,不能使用这个</li></ul><h2 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h2><ol><li>最方便的方式是将时间转为毫秒值进行计算<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date from =<span class="keyword">new</span> Date();</span><br><span class="line">Thread.sleep(<span class="number">200</span>);<span class="comment">//线程休眠2ms</span></span><br><span class="line">Date to =<span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(to.getTime()-from.getTime());</span><br></pre></td></tr></table></figure></li></ol><h2 id="高精度时间"><a href="#高精度时间" class="headerlink" title="高精度时间"></a>高精度时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time1 =System.nanoTime();</span><br><span class="line">System.out.printf(time1+<span class="string">""</span>);</span><br></pre></td></tr></table></figure><ul><li>说明:System.nanoTime()提高了ns级别的精度,1ms=1000000ns,</li></ul><h2 id="javascript日期"><a href="#javascript日期" class="headerlink" title="javascript日期"></a>javascript日期</h2><ol><li><p>获取时间的毫秒值，获取月份，时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">myDate.getYear(); <span class="comment">//获取当前年份(2位)</span></span><br><span class="line">myDate.getFullYear(); <span class="comment">//获取完整的年份(4位,1970-????)</span></span><br><span class="line">myDate.getMonth(); <span class="comment">//获取当前月份(0-11,0代表1月)</span></span><br><span class="line">myDate.getDate(); <span class="comment">//获取当前日(1-31)</span></span><br><span class="line">myDate.getDay(); <span class="comment">//获取当前星期X(0-6,0代表星期天)</span></span><br><span class="line">myDate.getTime(); <span class="comment">//获取当前时间(从1970.1.1开始的毫秒数)</span></span><br><span class="line">myDate.getHours(); <span class="comment">//获取当前小时数(0-23)</span></span><br><span class="line">myDate.getMinutes(); <span class="comment">//获取当前分钟数(0-59)</span></span><br><span class="line">myDate.getSeconds(); <span class="comment">//获取当前秒数(0-59)</span></span><br><span class="line">myDate.getMilliseconds(); <span class="comment">//获取当前毫秒数(0-999)</span></span><br><span class="line">myDate.toLocaleDateString(); <span class="comment">//获取当前日期</span></span><br><span class="line"><span class="keyword">var</span> mytime=myDate.toLocaleTimeString(); <span class="comment">//获取当前时间</span></span><br><span class="line">myDate.toLocaleString( ); <span class="comment">//获取日期与时间</span></span><br></pre></td></tr></table></figure></li><li><p>时间戳获取<br>注意，java，php等生成的时间戳是秒，不是毫秒，所以需要签名时间戳的时候，需要转为秒时间戳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="built_in">parseInt</span>(time.getTime()/<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>格式化时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间，格式YYYY-MM-DD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNowFormatDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> seperator1 = <span class="string">"-"</span>;</span><br><span class="line">    <span class="keyword">var</span> year = date.getFullYear();</span><br><span class="line">    <span class="keyword">var</span> month = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> strDate = date.getDate();</span><br><span class="line">    <span class="keyword">if</span> (month &gt;= <span class="number">1</span> &amp;&amp; month &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">        month = <span class="string">"0"</span> + month;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strDate &gt;= <span class="number">0</span> &amp;&amp; strDate &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">        strDate = <span class="string">"0"</span> + strDate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> currentdate = year + seperator1 + month + seperator1 + strDate;</span><br><span class="line">    <span class="keyword">return</span> currentdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** java，js日期转换：** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    java的各种日期转换&lt;/p&gt;
    
    </summary>
    
      <category term="language" scheme="https://SarkerAllen.github.io/categories/language/"/>
    
    
      <category term="java" scheme="https://SarkerAllen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_804_题目解答</title>
    <link href="https://SarkerAllen.github.io/2019/05/13/LeetCode_804/"/>
    <id>https://SarkerAllen.github.io/2019/05/13/LeetCode_804/</id>
    <published>2019-05-13T13:48:00.000Z</published>
    <updated>2019-07-16T10:27:43.859Z</updated>
    
    <content type="html"><![CDATA[<p>** LeetCode——804** &lt;Excerpt in index | 首页摘要&gt;<br>    LeetCode——804——题目分析与C语言实现</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="LeetCode-804-Unique-Morse-Code-Words"><a href="#LeetCode-804-Unique-Morse-Code-Words" class="headerlink" title="LeetCode_804_Unique Morse Code Words"></a>LeetCode_804_Unique Morse Code Words</h2><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><pre><code>1.建立Morse对照数组2.声明一个数组用于存放一个字符串的Morse对应编码3.声明一个数组用于存放重复的Morse码4.将字符串逐个转化为Morse码5.将字符串的Morse码与数组中的每一个Morse码对比，如果相同则退出比较，如果该Morse码不存在与数组中，则将该Morse码添加至该数组</code></pre><h2 id="代码实现-C语言"><a href="#代码实现-C语言" class="headerlink" title="代码实现(C语言)"></a>代码实现(C语言)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(<span class="keyword">char</span> ** words, <span class="keyword">int</span> wordsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> morse[][<span class="number">5</span>]=&#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,</span><br><span class="line">    <span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, find, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> unique[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="string">""</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; wordsSize; i++)&#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="built_in">string</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span>(words[i][j])&#123;</span><br><span class="line">            <span class="built_in">strcat</span>(<span class="built_in">string</span>, morse[words[i][j++] - <span class="string">'a'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        find = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; count; k++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="built_in">string</span>, unique[k]) == <span class="number">0</span>)&#123;</span><br><span class="line">                 find = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!find)&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(unique[count++], <span class="built_in">string</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** LeetCode——804** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    LeetCode——804——题目分析与C语言实现&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://SarkerAllen.github.io/categories/algorithm/"/>
    
    
      <category term="C" scheme="https://SarkerAllen.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——938算法</title>
    <link href="https://SarkerAllen.github.io/2019/05/13/LeetCode_938/"/>
    <id>https://SarkerAllen.github.io/2019/05/13/LeetCode_938/</id>
    <published>2019-05-13T13:48:00.000Z</published>
    <updated>2019-07-16T10:30:46.709Z</updated>
    
    <content type="html"><![CDATA[<p>** LeetCode题目解答** &lt;Excerpt in index | 首页摘要&gt;<br>    LeetCode——938题目C语言实现</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h2 id="LeetCode-938-Range-Sum-of-BST"><a href="#LeetCode-938-Range-Sum-of-BST" class="headerlink" title="LeetCode_938_Range Sum of BST"></a>LeetCode_938_Range Sum of BST</h2><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><pre><code>1.遍历二叉树2.如果val&lt;L,则遍历另一个节点3.如果val&gt;R,则遍历另一个节点4.如果val&gt;L&amp;&amp;val&lt;R,则sum+=val,然后遍历此节点的子节点</code></pre><h2 id="代码实现（C语言）"><a href="#代码实现（C语言）" class="headerlink" title="代码实现（C语言）"></a>代码实现（C语言）</h2><h3 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; L)&#123;</span><br><span class="line">        sum += rangeSumBST(root-&gt;right, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; R)&#123;</span><br><span class="line">        sum += rangeSumBST(root-&gt;left, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        sum += rangeSumBST(root-&gt;left, L, R);</span><br><span class="line">        sum += rangeSumBST(root-&gt;right, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;** LeetCode题目解答** &amp;lt;Excerpt in index | 首页摘要&amp;gt;&lt;br&gt;    LeetCode——938题目C语言实现&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://SarkerAllen.github.io/categories/algorithm/"/>
    
    
      <category term="C" scheme="https://SarkerAllen.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://SarkerAllen.github.io/2019/01/01/hello-world/"/>
    <id>https://SarkerAllen.github.io/2019/01/01/hello-world/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-07-18T15:59:36.231Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
